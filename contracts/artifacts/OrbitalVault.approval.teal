#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 1000000 4 10000 1000000000000
    bytecblock "lastRateSnapshot" "totalShares" "totalPrincipal" "usdcAssetId" "cUsdcAssetId" "usdcYieldPerShare" "userShares" "isPaused" "earnedAsa" "userUnrealizedUsdc" "creator" "projectAsaId" "orbitalAppId" "userUsdcYieldPerShare" "rarefiAddress" "withdrawFeeBps" "tinymanPoolAppId" "tinymanPoolAddress" "lastHarvestYieldPerShare" "lastHarvestAsaPerUsdc" "minHarvestThreshold" "depositFeeBps" "redeem" 0x151f7c75 "asaYieldPerShare"
    // OrbitalVault.algo.ts:36
    // export class OrbitalVault extends arc4.Contract {
    txn NumAppArgs
    bz main_bare_routing@23
    pushbytess 0x29314d95 0x6a691fe2 // method "optIn()void", method "closeOut()void"
    txna ApplicationArgs 0
    match main_optIn_route@3 main_closeOut_route@4

main_switch_case_next@5:
    // OrbitalVault.algo.ts:36
    // export class OrbitalVault extends arc4.Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@19
    pushbytess 0x414e41b5 0x92e03b1c 0x21f1ddff 0xab5b06c5 0x9c192d3f 0xcf61a1a4 0x6a1314bf 0x5d15133b 0x4e37efbd 0xb628a0f3 0x1ef7b586 // method "optInAssets()void", method "deposit()void", method "withdraw(uint64)void", method "claimYield()void", method "harvestAndSwap(uint64)void", method "getVaultStats()(uint64,uint64,uint64,uint64,uint64)", method "getUserPosition(address)(uint64,uint64,uint64,uint64)", method "getPendingYield(address)(uint64,uint64)", method "setPaused(bool)void", method "updateMinHarvestThreshold(uint64)void", method "updateTinymanPool(uint64,address)void"
    txna ApplicationArgs 0
    match optInAssets deposit withdraw claimYield harvestAndSwap getVaultStats getUserPosition getPendingYield setPaused updateMinHarvestThreshold updateTinymanPool
    err

main_create_NoOp@19:
    // OrbitalVault.algo.ts:36
    // export class OrbitalVault extends arc4.Contract {
    pushbytes 0x2fc0b329 // method "createVault(uint64,uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,address)void"
    txna ApplicationArgs 0
    match createVault
    err

main_closeOut_route@4:
    // OrbitalVault.algo.ts:401
    // @arc4.abimethod({ allowActions: 'CloseOut' })
    txn OnCompletion
    pushint 2 // CloseOut
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be CloseOut && can only call when not creating
    b closeOut

main_optIn_route@3:
    // OrbitalVault.algo.ts:385
    // @arc4.abimethod({ allowActions: 'OptIn' })
    txn OnCompletion
    intc_1 // OptIn
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be OptIn && can only call when not creating
    b optIn

main_bare_routing@23:
    // OrbitalVault.algo.ts:36
    // export class OrbitalVault extends arc4.Contract {
    intc_3 // UpdateApplication
    pushint 5 // DeleteApplication
    txn OnCompletion
    match main_updateApplication@24 main_deleteApplication@25
    err

main_deleteApplication@25:
    // OrbitalVault.algo.ts:893
    // @baremethod({ allowActions: 'DeleteApplication' })
    txn ApplicationID
    assert // can only call when not creating
    // OrbitalVault.algo.ts:895
    // assert(false, 'Contract deletion disabled');
    err // Contract deletion disabled

main_updateApplication@24:
    // OrbitalVault.algo.ts:888
    // @baremethod({ allowActions: 'UpdateApplication' })
    txn ApplicationID
    assert // can only call when not creating
    // OrbitalVault.algo.ts:890
    // assert(false, 'Contract updates disabled');
    err // Contract updates disabled


// OrbitalVault.algo.ts::OrbitalVault.createVault[routing]() -> void:
createVault:
    // OrbitalVault.algo.ts:259
    // @arc4.abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 6
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 7
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 8
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 9
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 10
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // OrbitalVault.algo.ts:273
    // assert(usdcAssetId !== Uint64(0), 'Invalid USDC asset ID');
    dig 9
    assert // Invalid USDC asset ID
    // OrbitalVault.algo.ts:274
    // assert(cUsdcAssetId !== Uint64(0), 'Invalid cUSDC asset ID');
    dig 8
    assert // Invalid cUSDC asset ID
    // OrbitalVault.algo.ts:275
    // assert(projectAsaId !== Uint64(0), 'Invalid project ASA ID');
    dig 7
    assert // Invalid project ASA ID
    // OrbitalVault.algo.ts:276
    // assert(orbitalAppId !== Uint64(0), 'Invalid Orbital app ID');
    dig 6
    assert // Invalid Orbital app ID
    // OrbitalVault.algo.ts:277
    // assert(tinymanPoolAppId !== Uint64(0), 'Invalid Tinyman pool app ID');
    dig 5
    assert // Invalid Tinyman pool app ID
    // OrbitalVault.algo.ts:278
    // assert(depositFeeBps <= MAX_FEE_BPS, 'Deposit fee too high');
    dig 3
    pushint 500 // 500
    <=
    assert // Deposit fee too high
    // OrbitalVault.algo.ts:279
    // assert(withdrawFeeBps <= MAX_FEE_BPS, 'Withdraw fee too high');
    dig 2
    pushint 500 // 500
    <=
    assert // Withdraw fee too high
    // OrbitalVault.algo.ts:280
    // assert(minHarvestThreshold >= MIN_HARVEST_THRESHOLD, 'Harvest threshold too low');
    dig 1
    intc_2 // 1000000
    >=
    assert // Harvest threshold too low
    // OrbitalVault.algo.ts:283
    // assert(usdcAssetId !== cUsdcAssetId, 'USDC and cUSDC must be different');
    dig 9
    dig 9
    !=
    assert // USDC and cUSDC must be different
    // OrbitalVault.algo.ts:284
    // assert(usdcAssetId !== projectAsaId, 'USDC and project ASA must be different');
    dig 9
    dig 8
    !=
    assert // USDC and project ASA must be different
    // OrbitalVault.algo.ts:42
    // creator = GlobalState<Account>();           // Vault creator/admin
    bytec 10 // "creator"
    // OrbitalVault.algo.ts:287
    // this.creator.value = Txn.sender;
    txn Sender
    app_global_put
    // OrbitalVault.algo.ts:43
    // rarefiAddress = GlobalState<Account>();     // RareFi platform address
    bytec 14 // "rarefiAddress"
    // OrbitalVault.algo.ts:288
    // this.rarefiAddress.value = rarefiAddress;
    swap
    app_global_put
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:291
    // this.isPaused.value = false;
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:294
    // this.usdcAssetId.value = usdcAssetId;
    uncover 9
    app_global_put
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:295
    // this.cUsdcAssetId.value = cUsdcAssetId;
    uncover 8
    app_global_put
    // OrbitalVault.algo.ts:51
    // projectAsaId = GlobalState<uint64>();       // Project ASA (yield paid in this)
    bytec 11 // "projectAsaId"
    // OrbitalVault.algo.ts:296
    // this.projectAsaId.value = projectAsaId;
    uncover 7
    app_global_put
    // OrbitalVault.algo.ts:54
    // orbitalAppId = GlobalState<uint64>();       // Orbital Lending app ID
    bytec 12 // "orbitalAppId"
    // OrbitalVault.algo.ts:299
    // this.orbitalAppId.value = orbitalAppId;
    uncover 6
    app_global_put
    // OrbitalVault.algo.ts:55
    // tinymanPoolAppId = GlobalState<uint64>();   // Tinyman V2 pool app ID
    bytec 16 // "tinymanPoolAppId"
    // OrbitalVault.algo.ts:300
    // this.tinymanPoolAppId.value = tinymanPoolAppId;
    uncover 5
    app_global_put
    // OrbitalVault.algo.ts:56
    // tinymanPoolAddress = GlobalState<Account>();// Tinyman pool address
    bytec 17 // "tinymanPoolAddress"
    // OrbitalVault.algo.ts:301
    // this.tinymanPoolAddress.value = tinymanPoolAddress;
    uncover 4
    app_global_put
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:304
    // this.totalShares.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:305
    // this.totalPrincipal.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:308
    // this.usdcYieldPerShare.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:64
    // asaYieldPerShare = GlobalState<uint64>();   // Stage 2: ASA yield accumulator (after harvest)
    bytec 24 // "asaYieldPerShare"
    // OrbitalVault.algo.ts:309
    // this.asaYieldPerShare.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:310
    // this.lastRateSnapshot.value = Uint64(0); // Will be set on optInAssets
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:68
    // lastHarvestYieldPerShare = GlobalState<uint64>(); // usdcYieldPerShare at last harvest
    bytec 18 // "lastHarvestYieldPerShare"
    // OrbitalVault.algo.ts:313
    // this.lastHarvestYieldPerShare.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:69
    // lastHarvestAsaPerUsdc = GlobalState<uint64>();    // Conversion rate from last harvest
    bytec 19 // "lastHarvestAsaPerUsdc"
    // OrbitalVault.algo.ts:314
    // this.lastHarvestAsaPerUsdc.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // OrbitalVault.algo.ts:70
    // minHarvestThreshold = GlobalState<uint64>();      // Minimum USDC yield before harvest
    bytec 20 // "minHarvestThreshold"
    // OrbitalVault.algo.ts:315
    // this.minHarvestThreshold.value = minHarvestThreshold;
    swap
    app_global_put
    // OrbitalVault.algo.ts:73
    // depositFeeBps = GlobalState<uint64>();      // Deposit fee in basis points
    bytec 21 // "depositFeeBps"
    // OrbitalVault.algo.ts:318
    // this.depositFeeBps.value = depositFeeBps;
    uncover 2
    app_global_put
    // OrbitalVault.algo.ts:74
    // withdrawFeeBps = GlobalState<uint64>();     // Withdraw fee in basis points
    bytec 15 // "withdrawFeeBps"
    // OrbitalVault.algo.ts:319
    // this.withdrawFeeBps.value = withdrawFeeBps;
    swap
    app_global_put
    // OrbitalVault.algo.ts:259
    // @arc4.abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.optInAssets[routing]() -> void:
optInAssets:
    // OrbitalVault.algo.ts:327
    // assert(Txn.sender === this.creator.value, 'Only creator can opt-in assets');
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:42
    // creator = GlobalState<Account>();           // Vault creator/admin
    bytec 10 // "creator"
    // OrbitalVault.algo.ts:327
    // assert(Txn.sender === this.creator.value, 'Only creator can opt-in assets');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only creator can opt-in assets
    // OrbitalVault.algo.ts:328
    // assert(!this.isPaused.value, 'Contract is paused');
    intc_0 // 0
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:328
    // assert(!this.isPaused.value, 'Contract is paused');
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Contract is paused
    // OrbitalVault.algo.ts:330
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // OrbitalVault.algo.ts:335
    // const currentIndex = Txn.groupIndex;
    txn GroupIndex
    // OrbitalVault.algo.ts:336
    // assert(currentIndex >= Uint64(1), 'App call must follow payment');
    dup
    assert // App call must follow payment
    // OrbitalVault.algo.ts:338
    // const algoPayment = gtxn.PaymentTxn(currentIndex - Uint64(1));
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // OrbitalVault.algo.ts:339
    // assert(algoPayment.receiver === appAddr, 'Payment must be to app');
    dup
    gtxns Receiver
    dig 2
    ==
    assert // Payment must be to app
    // OrbitalVault.algo.ts:340
    // assert(algoPayment.amount >= totalRequired, 'Insufficient ALGO');
    dup
    gtxns Amount
    pushint 200300000 // 200300000
    >=
    assert // Insufficient ALGO
    // OrbitalVault.algo.ts:341
    // assert(algoPayment.sender === Txn.sender, 'Payment must be from caller');
    gtxns Sender
    txn Sender
    ==
    assert // Payment must be from caller
    // OrbitalVault.algo.ts:344-348
    // itxn.payment({
    //   receiver: this.rarefiAddress.value,
    //   amount: CREATOR_SETUP_FEE,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:345
    // receiver: this.rarefiAddress.value,
    intc_0 // 0
    // OrbitalVault.algo.ts:43
    // rarefiAddress = GlobalState<Account>();     // RareFi platform address
    bytec 14 // "rarefiAddress"
    // OrbitalVault.algo.ts:345
    // receiver: this.rarefiAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:346
    // amount: CREATOR_SETUP_FEE,
    pushint 200000000 // 200000000
    itxn_field Amount
    itxn_field Receiver
    // OrbitalVault.algo.ts:344-348
    // itxn.payment({
    //   receiver: this.rarefiAddress.value,
    //   amount: CREATOR_SETUP_FEE,
    //   fee: Uint64(0),
    // }).submit();
    intc_1 // 1
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:347
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:344-348
    // itxn.payment({
    //   receiver: this.rarefiAddress.value,
    //   amount: CREATOR_SETUP_FEE,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // OrbitalVault.algo.ts:351-356
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:353
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:353
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:354
    // assetAmount: Uint64(0),
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    dup
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:351-356
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:355
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:351-356
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // OrbitalVault.algo.ts:359-364
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:361
    // xferAsset: Asset(this.cUsdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:361
    // xferAsset: Asset(this.cUsdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:362
    // assetAmount: Uint64(0),
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    dup
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:359-364
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:363
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:359-364
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // OrbitalVault.algo.ts:367-372
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:369
    // xferAsset: Asset(this.projectAsaId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:51
    // projectAsaId = GlobalState<uint64>();       // Project ASA (yield paid in this)
    bytec 11 // "projectAsaId"
    // OrbitalVault.algo.ts:369
    // xferAsset: Asset(this.projectAsaId.value),
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:370
    // assetAmount: Uint64(0),
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:367-372
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:371
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:367-372
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // OrbitalVault.algo.ts:375
    // this.lastRateSnapshot.value = this.fetchCurrentRate();
    callsub fetchCurrentRate
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:375
    // this.lastRateSnapshot.value = this.fetchCurrentRate();
    swap
    app_global_put
    // OrbitalVault.algo.ts:325
    // @arc4.abimethod()
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.optIn[routing]() -> void:
optIn:
    // OrbitalVault.algo.ts:387
    // assert(!this.isPaused.value, 'Contract is paused');
    intc_0 // 0
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:387
    // assert(!this.isPaused.value, 'Contract is paused');
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Contract is paused
    // OrbitalVault.algo.ts:390
    // this.userShares(Txn.sender).value = Uint64(0);
    txn Sender
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:390
    // this.userShares(Txn.sender).value = Uint64(0);
    intc_0 // 0
    app_local_put
    // OrbitalVault.algo.ts:391
    // this.userUsdcYieldPerShare(Txn.sender).value = this.usdcYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:391
    // this.userUsdcYieldPerShare(Txn.sender).value = this.usdcYieldPerShare.value;
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    // OrbitalVault.algo.ts:81
    // userUsdcYieldPerShare = LocalState<uint64>();   // Snapshot of usdcYieldPerShare
    bytec 13 // "userUsdcYieldPerShare"
    // OrbitalVault.algo.ts:391
    // this.userUsdcYieldPerShare(Txn.sender).value = this.usdcYieldPerShare.value;
    uncover 2
    app_local_put
    // OrbitalVault.algo.ts:392
    // this.userAsaYieldPerShare(Txn.sender).value = this.asaYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:64
    // asaYieldPerShare = GlobalState<uint64>();   // Stage 2: ASA yield accumulator (after harvest)
    bytec 24 // "asaYieldPerShare"
    // OrbitalVault.algo.ts:392
    // this.userAsaYieldPerShare(Txn.sender).value = this.asaYieldPerShare.value;
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    // OrbitalVault.algo.ts:82
    // userAsaYieldPerShare = LocalState<uint64>();    // Snapshot of asaYieldPerShare
    pushbytes "userAsaYieldPerShare"
    // OrbitalVault.algo.ts:392
    // this.userAsaYieldPerShare(Txn.sender).value = this.asaYieldPerShare.value;
    uncover 2
    app_local_put
    // OrbitalVault.algo.ts:393
    // this.userUnrealizedUsdc(Txn.sender).value = Uint64(0);
    txn Sender
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:393
    // this.userUnrealizedUsdc(Txn.sender).value = Uint64(0);
    intc_0 // 0
    app_local_put
    // OrbitalVault.algo.ts:394
    // this.earnedAsa(Txn.sender).value = Uint64(0);
    txn Sender
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:394
    // this.earnedAsa(Txn.sender).value = Uint64(0);
    intc_0 // 0
    app_local_put
    // OrbitalVault.algo.ts:385
    // @arc4.abimethod({ allowActions: 'OptIn' })
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.closeOut[routing]() -> void:
closeOut:
    pushbytes ""
    dup
    // OrbitalVault.algo.ts:404
    // this.updateUsdcYieldAccumulator();
    callsub updateUsdcYieldAccumulator
    // OrbitalVault.algo.ts:405
    // this.updateUserUsdcYield(Txn.sender);
    txn Sender
    callsub updateUserUsdcYield
    // OrbitalVault.algo.ts:406
    // this.updateUserAsaYield(Txn.sender);
    txn Sender
    callsub updateUserAsaYield
    // OrbitalVault.algo.ts:408
    // const userShareBalance = this.userShares(Txn.sender).value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:408
    // const userShareBalance = this.userShares(Txn.sender).value;
    app_local_get_ex
    swap
    dup
    uncover 2
    assert // check LocalState exists
    // OrbitalVault.algo.ts:409
    // const userAsaYield = this.earnedAsa(Txn.sender).value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:409
    // const userAsaYield = this.earnedAsa(Txn.sender).value;
    app_local_get_ex
    swap
    cover 2
    assert // check LocalState exists
    // OrbitalVault.algo.ts:412
    // if (userShareBalance > Uint64(0)) {
    bz closeOut_after_if_else@18
    // OrbitalVault.algo.ts:413
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // OrbitalVault.algo.ts:414
    // const currentRate = this.lastRateSnapshot.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:414
    // const currentRate = this.lastRateSnapshot.value;
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:417
    // const vaultCusdcBalance = Asset(this.cUsdcAssetId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:417
    // const vaultCusdcBalance = Asset(this.cUsdcAssetId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:422
    // const sharesToRedeem = userShareBalance <= vaultCusdcBalance
    dig 3
    dup
    cover 2
    dig 1
    <=
    // OrbitalVault.algo.ts:422-424
    // const sharesToRedeem = userShareBalance <= vaultCusdcBalance
    //   ? userShareBalance
    //   : vaultCusdcBalance;
    swap
    cover 2
    select
    dup
    bury 6
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:427
    // let usdcToReturn = this.mulDivFloor(sharesToRedeem, currentRate, RATE_PRECISION);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:430
    // if (this.withdrawFeeBps.value > Uint64(0)) {
    intc_0 // 0
    // OrbitalVault.algo.ts:74
    // withdrawFeeBps = GlobalState<uint64>();     // Withdraw fee in basis points
    bytec 15 // "withdrawFeeBps"
    // OrbitalVault.algo.ts:430
    // if (this.withdrawFeeBps.value > Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    bnz closeOut_if_body@3
    bury 3

closeOut_after_if_else@4:
    // OrbitalVault.algo.ts:436
    // this.totalShares.value = this.totalShares.value >= sharesToRedeem
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:436
    // this.totalShares.value = this.totalShares.value >= sharesToRedeem
    app_global_get_ex
    assert // check GlobalState exists
    dig 4
    >=
    // OrbitalVault.algo.ts:436-438
    // this.totalShares.value = this.totalShares.value >= sharesToRedeem
    //   ? this.totalShares.value - sharesToRedeem
    //   : Uint64(0);
    bz closeOut_ternary_false@6
    // OrbitalVault.algo.ts:437
    // ? this.totalShares.value - sharesToRedeem
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:437
    // ? this.totalShares.value - sharesToRedeem
    app_global_get_ex
    assert // check GlobalState exists
    dig 4
    -

closeOut_ternary_merge@7:
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:436-438
    // this.totalShares.value = this.totalShares.value >= sharesToRedeem
    //   ? this.totalShares.value - sharesToRedeem
    //   : Uint64(0);
    swap
    app_global_put
    // OrbitalVault.algo.ts:439
    // this.totalPrincipal.value = this.totalPrincipal.value >= usdcToReturn
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:439
    // this.totalPrincipal.value = this.totalPrincipal.value >= usdcToReturn
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    >=
    // OrbitalVault.algo.ts:439-441
    // this.totalPrincipal.value = this.totalPrincipal.value >= usdcToReturn
    //   ? this.totalPrincipal.value - usdcToReturn
    //   : Uint64(0);
    bz closeOut_ternary_false@9
    // OrbitalVault.algo.ts:440
    // ? this.totalPrincipal.value - usdcToReturn
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:440
    // ? this.totalPrincipal.value - usdcToReturn
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    -

closeOut_ternary_merge@10:
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:439-441
    // this.totalPrincipal.value = this.totalPrincipal.value >= usdcToReturn
    //   ? this.totalPrincipal.value - usdcToReturn
    //   : Uint64(0);
    swap
    app_global_put
    // OrbitalVault.algo.ts:444
    // if (sharesToRedeem > Uint64(0)) {
    dig 3
    bz closeOut_after_if_else@18
    // OrbitalVault.algo.ts:446-459
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.cUsdcAssetId.value),
    //     assetAmount: sharesToRedeem,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('redeem'), itob(sharesToRedeem)],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_begin
    // OrbitalVault.algo.ts:448
    // assetReceiver: Application(this.orbitalAppId.value).address,
    intc_0 // 0
    // OrbitalVault.algo.ts:54
    // orbitalAppId = GlobalState<uint64>();       // Orbital Lending app ID
    bytec 12 // "orbitalAppId"
    // OrbitalVault.algo.ts:448
    // assetReceiver: Application(this.orbitalAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    dup
    app_params_get AppAddress
    assert // application exists
    // OrbitalVault.algo.ts:449
    // xferAsset: Asset(this.cUsdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:449
    // xferAsset: Asset(this.cUsdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    dup
    cover 2
    itxn_field AssetAmount
    dup
    itxn_field XferAsset
    uncover 2
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:447-452
    // itxn.assetTransfer({
    //   assetReceiver: Application(this.orbitalAppId.value).address,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: sharesToRedeem,
    //   fee: Uint64(0),
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:451
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:453-458
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('redeem'), itob(sharesToRedeem)],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    itxn_next
    // OrbitalVault.algo.ts:455
    // appArgs: [Bytes('redeem'), itob(sharesToRedeem)],
    swap
    itob
    // OrbitalVault.algo.ts:456
    // assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:456
    // assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    app_global_get_ex
    assert // check GlobalState exists
    itxn_field Assets
    swap
    itxn_field Assets
    // OrbitalVault.algo.ts:455
    // appArgs: [Bytes('redeem'), itob(sharesToRedeem)],
    bytec 22 // "redeem"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // OrbitalVault.algo.ts:453-458
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('redeem'), itob(sharesToRedeem)],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    pushint 6 // 6
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:457
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:446-459
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.cUsdcAssetId.value),
    //     assetAmount: sharesToRedeem,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('redeem'), itob(sharesToRedeem)],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_submit
    // OrbitalVault.algo.ts:462
    // if (usdcToReturn > Uint64(0)) {
    dig 2
    bz closeOut_after_if_else@18
    // OrbitalVault.algo.ts:463-468
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcToReturn,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:464
    // assetReceiver: Txn.sender,
    txn Sender
    // OrbitalVault.algo.ts:465
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:465
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 4
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:463-468
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcToReturn,
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:467
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:463-468
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcToReturn,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit

closeOut_after_if_else@18:
    // OrbitalVault.algo.ts:474
    // if (userAsaYield > Uint64(0)) {
    dup
    bz closeOut_after_if_else@21
    // OrbitalVault.algo.ts:475-480
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: userAsaYield,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:476
    // assetReceiver: Txn.sender,
    txn Sender
    // OrbitalVault.algo.ts:477
    // xferAsset: Asset(this.projectAsaId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:51
    // projectAsaId = GlobalState<uint64>();       // Project ASA (yield paid in this)
    bytec 11 // "projectAsaId"
    // OrbitalVault.algo.ts:477
    // xferAsset: Asset(this.projectAsaId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:475-480
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: userAsaYield,
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:479
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:475-480
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: userAsaYield,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit

closeOut_after_if_else@21:
    // OrbitalVault.algo.ts:401
    // @arc4.abimethod({ allowActions: 'CloseOut' })
    intc_1 // 1
    return

closeOut_ternary_false@9:
    // OrbitalVault.algo.ts:441
    // : Uint64(0);
    intc_0 // 0
    b closeOut_ternary_merge@10

closeOut_ternary_false@6:
    // OrbitalVault.algo.ts:438
    // : Uint64(0);
    intc_0 // 0
    b closeOut_ternary_merge@7

closeOut_if_body@3:
    // OrbitalVault.algo.ts:431
    // const fee = this.mulDivFloor(usdcToReturn, this.withdrawFeeBps.value, FEE_BPS_BASE);
    intc_0 // 0
    // OrbitalVault.algo.ts:74
    // withdrawFeeBps = GlobalState<uint64>();     // Withdraw fee in basis points
    bytec 15 // "withdrawFeeBps"
    // OrbitalVault.algo.ts:431
    // const fee = this.mulDivFloor(usdcToReturn, this.withdrawFeeBps.value, FEE_BPS_BASE);
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 1
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:431
    // const fee = this.mulDivFloor(usdcToReturn, this.withdrawFeeBps.value, FEE_BPS_BASE);
    intc 4 // 10000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:432
    // usdcToReturn = usdcToReturn - fee;
    -
    bury 3
    b closeOut_after_if_else@4


// OrbitalVault.algo.ts::OrbitalVault.deposit[routing]() -> void:
deposit:
    // OrbitalVault.algo.ts:497
    // assert(!this.isPaused.value, 'Contract is paused');
    intc_0 // 0
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:497
    // assert(!this.isPaused.value, 'Contract is paused');
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Contract is paused
    // OrbitalVault.algo.ts:499
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    dup
    // OrbitalVault.algo.ts:500
    // const currentIndex = Txn.groupIndex;
    txn GroupIndex
    // OrbitalVault.algo.ts:501
    // assert(currentIndex >= Uint64(1), 'App call must follow asset transfer');
    dup
    assert // App call must follow asset transfer
    // OrbitalVault.algo.ts:504
    // const depositTransfer = gtxn.AssetTransferTxn(currentIndex - Uint64(1));
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    // OrbitalVault.algo.ts:505
    // assert(depositTransfer.xferAsset === Asset(this.usdcAssetId.value), 'Must transfer USDC');
    dup
    gtxns XferAsset
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:505
    // assert(depositTransfer.xferAsset === Asset(this.usdcAssetId.value), 'Must transfer USDC');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Must transfer USDC
    // OrbitalVault.algo.ts:506
    // assert(depositTransfer.assetReceiver === appAddr, 'Must send to contract');
    dup
    gtxns AssetReceiver
    uncover 2
    ==
    assert // Must send to contract
    // OrbitalVault.algo.ts:507
    // assert(depositTransfer.sender === Txn.sender, 'Transfer must be from caller');
    dup
    gtxns Sender
    txn Sender
    ==
    assert // Transfer must be from caller
    // OrbitalVault.algo.ts:509
    // let amount = depositTransfer.assetAmount;
    gtxns AssetAmount
    dup
    // OrbitalVault.algo.ts:510
    // assert(amount >= MIN_DEPOSIT_AMOUNT, 'Deposit too small');
    intc_2 // 1000000
    >=
    assert // Deposit too small
    // OrbitalVault.algo.ts:513
    // this.updateUsdcYieldAccumulator();
    callsub updateUsdcYieldAccumulator
    // OrbitalVault.algo.ts:514
    // this.updateUserUsdcYield(Txn.sender);
    txn Sender
    callsub updateUserUsdcYield
    // OrbitalVault.algo.ts:515
    // this.updateUserAsaYield(Txn.sender);
    txn Sender
    callsub updateUserAsaYield
    // OrbitalVault.algo.ts:518
    // if (this.depositFeeBps.value > Uint64(0)) {
    intc_0 // 0
    // OrbitalVault.algo.ts:73
    // depositFeeBps = GlobalState<uint64>();      // Deposit fee in basis points
    bytec 21 // "depositFeeBps"
    // OrbitalVault.algo.ts:518
    // if (this.depositFeeBps.value > Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    bz deposit_after_if_else@3
    // OrbitalVault.algo.ts:519
    // const fee = this.mulDivFloor(amount, this.depositFeeBps.value, FEE_BPS_BASE);
    intc_0 // 0
    // OrbitalVault.algo.ts:73
    // depositFeeBps = GlobalState<uint64>();      // Deposit fee in basis points
    bytec 21 // "depositFeeBps"
    // OrbitalVault.algo.ts:519
    // const fee = this.mulDivFloor(amount, this.depositFeeBps.value, FEE_BPS_BASE);
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 1
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:519
    // const fee = this.mulDivFloor(amount, this.depositFeeBps.value, FEE_BPS_BASE);
    intc 4 // 10000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:520
    // amount = amount - fee;
    -

deposit_after_if_else@3:
    // OrbitalVault.algo.ts:525
    // const cUsdcBefore = Asset(this.cUsdcAssetId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:525
    // const cUsdcBefore = Asset(this.cUsdcAssetId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    dup
    cover 2
    dig 1
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:528-541
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetAmount: amount,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('deposit')],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_begin
    // OrbitalVault.algo.ts:530
    // assetReceiver: Application(this.orbitalAppId.value).address,
    intc_0 // 0
    // OrbitalVault.algo.ts:54
    // orbitalAppId = GlobalState<uint64>();       // Orbital Lending app ID
    bytec 12 // "orbitalAppId"
    // OrbitalVault.algo.ts:530
    // assetReceiver: Application(this.orbitalAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    dup
    app_params_get AppAddress
    assert // application exists
    // OrbitalVault.algo.ts:531
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:531
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    itxn_field AssetAmount
    dup
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:529-534
    // itxn.assetTransfer({
    //   assetReceiver: Application(this.orbitalAppId.value).address,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: amount,
    //   fee: Uint64(0),
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:533
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:535-540
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('deposit')],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    itxn_next
    itxn_field Assets
    dig 2
    itxn_field Assets
    // OrbitalVault.algo.ts:537
    // appArgs: [Bytes('deposit')],
    pushbytes "deposit"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // OrbitalVault.algo.ts:535-540
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('deposit')],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    pushint 6 // 6
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:539
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:528-541
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetAmount: amount,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('deposit')],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_submit
    // OrbitalVault.algo.ts:544
    // const cUsdcAfter = Asset(this.cUsdcAssetId.value).balance(appAddr);
    cover 2
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:545
    // const cUsdcReceived: uint64 = cUsdcAfter - cUsdcBefore;
    swap
    -
    // OrbitalVault.algo.ts:547
    // assert(cUsdcReceived > Uint64(0), 'No cUSDC received from Orbital');
    dup
    assert // No cUSDC received from Orbital
    // OrbitalVault.algo.ts:550
    // this.userShares(Txn.sender).value = this.userShares(Txn.sender).value + cUsdcReceived;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:550
    // this.userShares(Txn.sender).value = this.userShares(Txn.sender).value + cUsdcReceived;
    app_local_get_ex
    assert // check LocalState exists
    dig 1
    +
    txn Sender
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:550
    // this.userShares(Txn.sender).value = this.userShares(Txn.sender).value + cUsdcReceived;
    uncover 2
    app_local_put
    // OrbitalVault.algo.ts:551
    // this.totalShares.value = this.totalShares.value + cUsdcReceived;
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:551
    // this.totalShares.value = this.totalShares.value + cUsdcReceived;
    app_global_get_ex
    assert // check GlobalState exists
    +
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:551
    // this.totalShares.value = this.totalShares.value + cUsdcReceived;
    swap
    app_global_put
    // OrbitalVault.algo.ts:552
    // this.totalPrincipal.value = this.totalPrincipal.value + amount;
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:552
    // this.totalPrincipal.value = this.totalPrincipal.value + amount;
    app_global_get_ex
    assert // check GlobalState exists
    +
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:552
    // this.totalPrincipal.value = this.totalPrincipal.value + amount;
    swap
    app_global_put
    // OrbitalVault.algo.ts:495
    // @arc4.abimethod()
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.withdraw[routing]() -> void:
withdraw:
    pushbytes ""
    dupn 2
    // OrbitalVault.algo.ts:559
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // OrbitalVault.algo.ts:561
    // assert(!this.isPaused.value, 'Contract is paused');
    intc_0 // 0
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:561
    // assert(!this.isPaused.value, 'Contract is paused');
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Contract is paused
    // OrbitalVault.algo.ts:564
    // this.updateUsdcYieldAccumulator();
    callsub updateUsdcYieldAccumulator
    // OrbitalVault.algo.ts:565
    // this.updateUserUsdcYield(Txn.sender);
    txn Sender
    callsub updateUserUsdcYield
    // OrbitalVault.algo.ts:566
    // this.updateUserAsaYield(Txn.sender);
    txn Sender
    callsub updateUserAsaYield
    // OrbitalVault.algo.ts:568
    // const userShareBalance = this.userShares(Txn.sender).value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:568
    // const userShareBalance = this.userShares(Txn.sender).value;
    app_local_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check LocalState exists
    // OrbitalVault.algo.ts:569
    // const currentRate = this.lastRateSnapshot.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:569
    // const currentRate = this.lastRateSnapshot.value;
    app_global_get_ex
    swap
    dup
    cover 2
    cover 4
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:572
    // const userUsdcValue = this.mulDivFloor(userShareBalance, currentRate, RATE_PRECISION);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    cover 2
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:575
    // if (withdrawAmount === Uint64(0)) {
    bz withdraw_if_body@2
    dig 3
    bury 5

withdraw_after_if_else@3:
    // OrbitalVault.algo.ts:579
    // assert(withdrawAmount > Uint64(0), 'Nothing to withdraw');
    dig 4
    dup
    assert // Nothing to withdraw
    // OrbitalVault.algo.ts:580
    // assert(withdrawAmount <= userUsdcValue, 'Insufficient balance');
    dup
    dig 2
    <=
    assert // Insufficient balance
    // OrbitalVault.algo.ts:583
    // const cUsdcToRedeem = this.mulDivCeil(withdrawAmount, RATE_PRECISION, currentRate);
    intc_2 // 1000000
    dig 3
    callsub mulDivCeil
    dup
    bury 8
    // OrbitalVault.algo.ts:584
    // assert(cUsdcToRedeem <= userShareBalance, 'Share calculation error');
    dup
    dig 4
    <=
    assert // Share calculation error
    // OrbitalVault.algo.ts:586
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // OrbitalVault.algo.ts:589
    // const usdcBefore = Asset(this.usdcAssetId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:589
    // const usdcBefore = Asset(this.usdcAssetId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    dup2
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:592-605
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.cUsdcAssetId.value),
    //     assetAmount: cUsdcToRedeem,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_begin
    // OrbitalVault.algo.ts:594
    // assetReceiver: Application(this.orbitalAppId.value).address,
    intc_0 // 0
    // OrbitalVault.algo.ts:54
    // orbitalAppId = GlobalState<uint64>();       // Orbital Lending app ID
    bytec 12 // "orbitalAppId"
    // OrbitalVault.algo.ts:594
    // assetReceiver: Application(this.orbitalAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    dup
    app_params_get AppAddress
    assert // application exists
    // OrbitalVault.algo.ts:595
    // xferAsset: Asset(this.cUsdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:595
    // xferAsset: Asset(this.cUsdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    itxn_field AssetAmount
    dup
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:593-598
    // itxn.assetTransfer({
    //   assetReceiver: Application(this.orbitalAppId.value).address,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: cUsdcToRedeem,
    //   fee: Uint64(0),
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:597
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:599-604
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    itxn_next
    // OrbitalVault.algo.ts:601
    // appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    uncover 5
    itob
    dig 4
    itxn_field Assets
    swap
    itxn_field Assets
    bytec 22 // "redeem"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // OrbitalVault.algo.ts:599-604
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    pushint 6 // 6
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:603
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:592-605
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.cUsdcAssetId.value),
    //     assetAmount: cUsdcToRedeem,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_submit
    // OrbitalVault.algo.ts:608
    // const usdcAfter = Asset(this.usdcAssetId.value).balance(appAddr);
    cover 2
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:609
    // let usdcReceived: uint64 = usdcAfter - usdcBefore;
    swap
    -
    bury 6
    // OrbitalVault.algo.ts:612
    // if (this.withdrawFeeBps.value > Uint64(0)) {
    intc_0 // 0
    // OrbitalVault.algo.ts:74
    // withdrawFeeBps = GlobalState<uint64>();     // Withdraw fee in basis points
    bytec 15 // "withdrawFeeBps"
    // OrbitalVault.algo.ts:612
    // if (this.withdrawFeeBps.value > Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    bz withdraw_after_if_else@7
    // OrbitalVault.algo.ts:613
    // const fee = this.mulDivFloor(usdcReceived, this.withdrawFeeBps.value, FEE_BPS_BASE);
    intc_0 // 0
    // OrbitalVault.algo.ts:74
    // withdrawFeeBps = GlobalState<uint64>();     // Withdraw fee in basis points
    bytec 15 // "withdrawFeeBps"
    // OrbitalVault.algo.ts:613
    // const fee = this.mulDivFloor(usdcReceived, this.withdrawFeeBps.value, FEE_BPS_BASE);
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 6
    dup
    uncover 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:613
    // const fee = this.mulDivFloor(usdcReceived, this.withdrawFeeBps.value, FEE_BPS_BASE);
    intc 4 // 10000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:614
    // usdcReceived = usdcReceived - fee;
    -
    bury 6

withdraw_after_if_else@7:
    // OrbitalVault.algo.ts:618
    // this.userShares(Txn.sender).value = userShareBalance - cUsdcToRedeem;
    dig 2
    dig 7
    dup
    cover 2
    -
    txn Sender
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:618
    // this.userShares(Txn.sender).value = userShareBalance - cUsdcToRedeem;
    uncover 2
    app_local_put
    // OrbitalVault.algo.ts:619
    // this.totalShares.value = this.totalShares.value - cUsdcToRedeem;
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:619
    // this.totalShares.value = this.totalShares.value - cUsdcToRedeem;
    app_global_get_ex
    assert // check GlobalState exists
    swap
    -
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:619
    // this.totalShares.value = this.totalShares.value - cUsdcToRedeem;
    swap
    app_global_put
    // OrbitalVault.algo.ts:622
    // if (this.totalPrincipal.value > withdrawAmount) {
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:622
    // if (this.totalPrincipal.value > withdrawAmount) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 5
    >
    bz withdraw_else_body@9
    // OrbitalVault.algo.ts:623
    // this.totalPrincipal.value = this.totalPrincipal.value - withdrawAmount;
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:623
    // this.totalPrincipal.value = this.totalPrincipal.value - withdrawAmount;
    app_global_get_ex
    assert // check GlobalState exists
    dig 5
    -
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:623
    // this.totalPrincipal.value = this.totalPrincipal.value - withdrawAmount;
    swap
    app_global_put

withdraw_after_if_else@10:
    // OrbitalVault.algo.ts:629-634
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcReceived,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:630
    // assetReceiver: Txn.sender,
    txn Sender
    // OrbitalVault.algo.ts:631
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:631
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 7
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:629-634
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcReceived,
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:633
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:629-634
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcReceived,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // OrbitalVault.algo.ts:559
    // @arc4.abimethod()
    intc_1 // 1
    return

withdraw_else_body@9:
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:625
    // this.totalPrincipal.value = Uint64(0);
    intc_0 // 0
    app_global_put
    b withdraw_after_if_else@10

withdraw_if_body@2:
    dup
    bury 5
    b withdraw_after_if_else@3


// OrbitalVault.algo.ts::OrbitalVault.claimYield[routing]() -> void:
claimYield:
    // OrbitalVault.algo.ts:646
    // assert(!this.isPaused.value, 'Contract is paused');
    intc_0 // 0
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:646
    // assert(!this.isPaused.value, 'Contract is paused');
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Contract is paused
    // OrbitalVault.algo.ts:649
    // this.updateUsdcYieldAccumulator();
    callsub updateUsdcYieldAccumulator
    // OrbitalVault.algo.ts:650
    // this.updateUserUsdcYield(Txn.sender);
    txn Sender
    callsub updateUserUsdcYield
    // OrbitalVault.algo.ts:651
    // this.updateUserAsaYield(Txn.sender);
    txn Sender
    callsub updateUserAsaYield
    // OrbitalVault.algo.ts:653
    // const claimable = this.earnedAsa(Txn.sender).value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:653
    // const claimable = this.earnedAsa(Txn.sender).value;
    app_local_get_ex
    assert // check LocalState exists
    // OrbitalVault.algo.ts:654
    // assert(claimable > Uint64(0), 'Nothing to claim');
    dup
    assert // Nothing to claim
    // OrbitalVault.algo.ts:657
    // this.earnedAsa(Txn.sender).value = Uint64(0);
    txn Sender
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:657
    // this.earnedAsa(Txn.sender).value = Uint64(0);
    intc_0 // 0
    app_local_put
    // OrbitalVault.algo.ts:660-665
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: claimable,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // OrbitalVault.algo.ts:661
    // assetReceiver: Txn.sender,
    txn Sender
    // OrbitalVault.algo.ts:662
    // xferAsset: Asset(this.projectAsaId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:51
    // projectAsaId = GlobalState<uint64>();       // Project ASA (yield paid in this)
    bytec 11 // "projectAsaId"
    // OrbitalVault.algo.ts:662
    // xferAsset: Asset(this.projectAsaId.value),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:660-665
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: claimable,
    //   fee: Uint64(0),
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:664
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:660-665
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.projectAsaId.value),
    //   assetAmount: claimable,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // OrbitalVault.algo.ts:644
    // @arc4.abimethod()
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.harvestAndSwap[routing]() -> void:
harvestAndSwap:
    pushbytes ""
    // OrbitalVault.algo.ts:676
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // OrbitalVault.algo.ts:678
    // const isCreator = Txn.sender === this.creator.value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:42
    // creator = GlobalState<Account>();           // Vault creator/admin
    bytec 10 // "creator"
    // OrbitalVault.algo.ts:678
    // const isCreator = Txn.sender === this.creator.value;
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // OrbitalVault.algo.ts:679
    // const isRarefi = Txn.sender === this.rarefiAddress.value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:43
    // rarefiAddress = GlobalState<Account>();     // RareFi platform address
    bytec 14 // "rarefiAddress"
    // OrbitalVault.algo.ts:679
    // const isRarefi = Txn.sender === this.rarefiAddress.value;
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // OrbitalVault.algo.ts:680
    // assert(isCreator || isRarefi, 'Only creator or RareFi can harvest');
    ||
    assert // Only creator or RareFi can harvest
    // OrbitalVault.algo.ts:681
    // assert(!this.isPaused.value, 'Contract is paused');
    intc_0 // 0
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:681
    // assert(!this.isPaused.value, 'Contract is paused');
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Contract is paused
    // OrbitalVault.algo.ts:682
    // assert(slippageBps <= MAX_SLIPPAGE_BPS, 'Slippage too high');
    pushint 1000 // 1000
    <=
    assert // Slippage too high
    // OrbitalVault.algo.ts:685
    // this.updateUsdcYieldAccumulator();
    callsub updateUsdcYieldAccumulator
    // OrbitalVault.algo.ts:687
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    dup
    // OrbitalVault.algo.ts:688
    // const currentRate = this.lastRateSnapshot.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:688
    // const currentRate = this.lastRateSnapshot.value;
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:689
    // const cUsdcBalance = Asset(this.cUsdcAssetId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:689
    // const cUsdcBalance = Asset(this.cUsdcAssetId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    swap
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 1
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:692
    // const currentValueUsdc = this.mulDivFloor(cUsdcBalance, currentRate, RATE_PRECISION);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:695
    // assert(currentValueUsdc >= this.totalPrincipal.value, 'No yield to harvest');
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:695
    // assert(currentValueUsdc >= this.totalPrincipal.value, 'No yield to harvest');
    app_global_get_ex
    assert // check GlobalState exists
    dup2
    >=
    assert // No yield to harvest
    // OrbitalVault.algo.ts:696
    // const totalUnrealizedUsdc: uint64 = currentValueUsdc - this.totalPrincipal.value;
    -
    // OrbitalVault.algo.ts:698
    // assert(totalUnrealizedUsdc >= this.minHarvestThreshold.value, 'Below minimum harvest threshold');
    intc_0 // 0
    // OrbitalVault.algo.ts:70
    // minHarvestThreshold = GlobalState<uint64>();      // Minimum USDC yield before harvest
    bytec 20 // "minHarvestThreshold"
    // OrbitalVault.algo.ts:698
    // assert(totalUnrealizedUsdc >= this.minHarvestThreshold.value, 'Below minimum harvest threshold');
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    <=
    assert // Below minimum harvest threshold
    // OrbitalVault.algo.ts:699
    // assert(this.totalShares.value > Uint64(0), 'No depositors');
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:699
    // assert(this.totalShares.value > Uint64(0), 'No depositors');
    app_global_get_ex
    assert // check GlobalState exists
    assert // No depositors
    // OrbitalVault.algo.ts:702
    // const cUsdcToRedeem = this.mulDivCeil(totalUnrealizedUsdc, RATE_PRECISION, currentRate);
    intc_2 // 1000000
    uncover 2
    callsub mulDivCeil
    // OrbitalVault.algo.ts:705
    // const usdcBefore = Asset(this.usdcAssetId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:705
    // const usdcBefore = Asset(this.usdcAssetId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    dig 1
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:708-721
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.cUsdcAssetId.value),
    //     assetAmount: cUsdcToRedeem,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_begin
    // OrbitalVault.algo.ts:710
    // assetReceiver: Application(this.orbitalAppId.value).address,
    intc_0 // 0
    // OrbitalVault.algo.ts:54
    // orbitalAppId = GlobalState<uint64>();       // Orbital Lending app ID
    bytec 12 // "orbitalAppId"
    // OrbitalVault.algo.ts:710
    // assetReceiver: Application(this.orbitalAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    dup
    app_params_get AppAddress
    assert // application exists
    // OrbitalVault.algo.ts:711
    // xferAsset: Asset(this.cUsdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:711
    // xferAsset: Asset(this.cUsdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 5
    itxn_field AssetAmount
    dup
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:709-714
    // itxn.assetTransfer({
    //   assetReceiver: Application(this.orbitalAppId.value).address,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: cUsdcToRedeem,
    //   fee: Uint64(0),
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:713
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:715-720
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    itxn_next
    // OrbitalVault.algo.ts:717
    // appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    dig 4
    itob
    dig 4
    itxn_field Assets
    swap
    itxn_field Assets
    bytec 22 // "redeem"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // OrbitalVault.algo.ts:715-720
    // itxn.applicationCall({
    //   appId: Application(this.orbitalAppId.value),
    //   appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //   assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //   fee: Uint64(0),
    // }),
    pushint 6 // 6
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:719
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:708-721
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: Application(this.orbitalAppId.value).address,
    //     xferAsset: Asset(this.cUsdcAssetId.value),
    //     assetAmount: cUsdcToRedeem,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.orbitalAppId.value),
    //     appArgs: [Bytes('redeem'), itob(cUsdcToRedeem)],
    //     assets: [Asset(this.usdcAssetId.value), Asset(this.cUsdcAssetId.value)],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_submit
    // OrbitalVault.algo.ts:724
    // const usdcAfter = Asset(this.usdcAssetId.value).balance(appAddr);
    uncover 3
    uncover 2
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:725
    // const usdcYield: uint64 = usdcAfter - usdcBefore;
    swap
    -
    swap
    // OrbitalVault.algo.ts:728
    // this.totalShares.value = this.totalShares.value - cUsdcToRedeem;
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:728
    // this.totalShares.value = this.totalShares.value - cUsdcToRedeem;
    app_global_get_ex
    assert // check GlobalState exists
    swap
    -
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:728
    // this.totalShares.value = this.totalShares.value - cUsdcToRedeem;
    swap
    app_global_put
    // OrbitalVault.algo.ts:216
    // const poolApp = this.tinymanPoolAppId.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:55
    // tinymanPoolAppId = GlobalState<uint64>();   // Tinyman V2 pool app ID
    bytec 16 // "tinymanPoolAppId"
    // OrbitalVault.algo.ts:216
    // const poolApp = this.tinymanPoolAppId.value;
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:219
    // const [asset1Id, hasAsset1Id] = AppGlobal.getExUint64(poolApp, Bytes('asset_1_id'));
    dup
    pushbytes "asset_1_id"
    app_global_get_ex
    // OrbitalVault.algo.ts:220
    // assert(hasAsset1Id, 'Cannot read pool asset_1_id');
    assert // Cannot read pool asset_1_id
    // OrbitalVault.algo.ts:222
    // const [asset1Reserves, hasAsset1Reserves] = AppGlobal.getExUint64(poolApp, Bytes('asset_1_reserves'));
    dig 1
    pushbytes "asset_1_reserves"
    app_global_get_ex
    swap
    cover 3
    // OrbitalVault.algo.ts:223
    // assert(hasAsset1Reserves, 'Cannot read pool asset_1_reserves');
    assert // Cannot read pool asset_1_reserves
    // OrbitalVault.algo.ts:225
    // const [asset2Reserves, hasAsset2Reserves] = AppGlobal.getExUint64(poolApp, Bytes('asset_2_reserves'));
    dig 1
    pushbytes "asset_2_reserves"
    app_global_get_ex
    swap
    cover 3
    // OrbitalVault.algo.ts:226
    // assert(hasAsset2Reserves, 'Cannot read pool asset_2_reserves');
    assert // Cannot read pool asset_2_reserves
    // OrbitalVault.algo.ts:228
    // const [totalFeeShare, hasTotalFeeShare] = AppGlobal.getExUint64(poolApp, Bytes('total_fee_share'));
    swap
    pushbytes "total_fee_share"
    app_global_get_ex
    swap
    cover 3
    // OrbitalVault.algo.ts:229
    // assert(hasTotalFeeShare, 'Cannot read pool total_fee_share');
    assert // Cannot read pool total_fee_share
    // OrbitalVault.algo.ts:235
    // if (asset1Id === this.usdcAssetId.value) {
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:235
    // if (asset1Id === this.usdcAssetId.value) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz harvestAndSwap_else_body@3
    dig 2
    bury 7

harvestAndSwap_after_if_else@4:
    // OrbitalVault.algo.ts:244
    // const netInput = this.mulDivFloor(inputAmount, FEE_BPS_BASE - totalFeeShare, FEE_BPS_BASE);
    intc 4 // 10000
    dig 2
    -
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 4
    dup
    uncover 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:244
    // const netInput = this.mulDivFloor(inputAmount, FEE_BPS_BASE - totalFeeShare, FEE_BPS_BASE);
    intc 4 // 10000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:247
    // const expectedOutput = this.mulDivFloor(outputReserves, netInput, inputReserves + netInput);
    dig 8
    dig 1
    +
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    uncover 3
    uncover 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    uncover 3
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:732
    // assert(expectedOutput > Uint64(0), 'Expected swap output is zero');
    dup
    assert // Expected swap output is zero
    // OrbitalVault.algo.ts:735
    // const minAmountOut = this.mulDivFloor(expectedOutput, FEE_BPS_BASE - slippageBps, FEE_BPS_BASE);
    intc 4 // 10000
    dig 7
    -
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:735
    // const minAmountOut = this.mulDivFloor(expectedOutput, FEE_BPS_BASE - slippageBps, FEE_BPS_BASE);
    intc 4 // 10000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:738
    // const asaBefore = Asset(this.projectAsaId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:51
    // projectAsaId = GlobalState<uint64>();       // Project ASA (yield paid in this)
    bytec 11 // "projectAsaId"
    // OrbitalVault.algo.ts:738
    // const asaBefore = Asset(this.projectAsaId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    dup
    cover 3
    dig 1
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:741-755
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: this.tinymanPoolAddress.value,
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetAmount: usdcYield,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.tinymanPoolAppId.value),
    //     appArgs: [Bytes('swap'), Bytes('fixed-input'), itob(minAmountOut)],
    //     assets: [Asset(this.projectAsaId.value)],
    //     accounts: [this.tinymanPoolAddress.value],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_begin
    // OrbitalVault.algo.ts:743
    // assetReceiver: this.tinymanPoolAddress.value,
    intc_0 // 0
    // OrbitalVault.algo.ts:56
    // tinymanPoolAddress = GlobalState<Account>();// Tinyman pool address
    bytec 17 // "tinymanPoolAddress"
    // OrbitalVault.algo.ts:743
    // assetReceiver: this.tinymanPoolAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:744
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:49
    // usdcAssetId = GlobalState<uint64>();        // USDC asset ID
    bytec_3 // "usdcAssetId"
    // OrbitalVault.algo.ts:744
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    itxn_field AssetAmount
    itxn_field XferAsset
    dup
    itxn_field AssetReceiver
    // OrbitalVault.algo.ts:742-747
    // itxn.assetTransfer({
    //   assetReceiver: this.tinymanPoolAddress.value,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcYield,
    //   fee: Uint64(0),
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:746
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:748-754
    // itxn.applicationCall({
    //   appId: Application(this.tinymanPoolAppId.value),
    //   appArgs: [Bytes('swap'), Bytes('fixed-input'), itob(minAmountOut)],
    //   assets: [Asset(this.projectAsaId.value)],
    //   accounts: [this.tinymanPoolAddress.value],
    //   fee: Uint64(0),
    // }),
    itxn_next
    // OrbitalVault.algo.ts:749
    // appId: Application(this.tinymanPoolAppId.value),
    intc_0 // 0
    // OrbitalVault.algo.ts:55
    // tinymanPoolAppId = GlobalState<uint64>();   // Tinyman V2 pool app ID
    bytec 16 // "tinymanPoolAppId"
    // OrbitalVault.algo.ts:749
    // appId: Application(this.tinymanPoolAppId.value),
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:750
    // appArgs: [Bytes('swap'), Bytes('fixed-input'), itob(minAmountOut)],
    dig 4
    itob
    uncover 2
    itxn_field Accounts
    dig 3
    itxn_field Assets
    pushbytes "swap"
    itxn_field ApplicationArgs
    pushbytes "fixed-input"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // OrbitalVault.algo.ts:748-754
    // itxn.applicationCall({
    //   appId: Application(this.tinymanPoolAppId.value),
    //   appArgs: [Bytes('swap'), Bytes('fixed-input'), itob(minAmountOut)],
    //   assets: [Asset(this.projectAsaId.value)],
    //   accounts: [this.tinymanPoolAddress.value],
    //   fee: Uint64(0),
    // }),
    pushint 6 // 6
    itxn_field TypeEnum
    // OrbitalVault.algo.ts:753
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // OrbitalVault.algo.ts:741-755
    // itxn.submitGroup(
    //   itxn.assetTransfer({
    //     assetReceiver: this.tinymanPoolAddress.value,
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetAmount: usdcYield,
    //     fee: Uint64(0),
    //   }),
    //   itxn.applicationCall({
    //     appId: Application(this.tinymanPoolAppId.value),
    //     appArgs: [Bytes('swap'), Bytes('fixed-input'), itob(minAmountOut)],
    //     assets: [Asset(this.projectAsaId.value)],
    //     accounts: [this.tinymanPoolAddress.value],
    //     fee: Uint64(0),
    //   }),
    // );
    itxn_submit
    // OrbitalVault.algo.ts:758
    // const asaAfter = Asset(this.projectAsaId.value).balance(appAddr);
    uncover 3
    uncover 2
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:759
    // const asaReceived: uint64 = asaAfter - asaBefore;
    swap
    -
    // OrbitalVault.algo.ts:761
    // assert(asaReceived >= minAmountOut, 'Swap output below minimum');
    dup
    uncover 2
    >=
    assert // Swap output below minimum
    // OrbitalVault.algo.ts:764
    // const asaPerUsdc = this.mulDivFloor(asaReceived, ASA_SCALE, usdcYield);
    intc 5 // 1000000000000
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    uncover 3
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:69
    // lastHarvestAsaPerUsdc = GlobalState<uint64>();    // Conversion rate from last harvest
    bytec 19 // "lastHarvestAsaPerUsdc"
    // OrbitalVault.algo.ts:767
    // this.lastHarvestAsaPerUsdc.value = asaPerUsdc;
    swap
    app_global_put
    // OrbitalVault.algo.ts:768
    // this.lastHarvestYieldPerShare.value = this.usdcYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:768
    // this.lastHarvestYieldPerShare.value = this.usdcYieldPerShare.value;
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:68
    // lastHarvestYieldPerShare = GlobalState<uint64>(); // usdcYieldPerShare at last harvest
    bytec 18 // "lastHarvestYieldPerShare"
    // OrbitalVault.algo.ts:768
    // this.lastHarvestYieldPerShare.value = this.usdcYieldPerShare.value;
    swap
    app_global_put
    // OrbitalVault.algo.ts:676
    // @arc4.abimethod()
    intc_1 // 1
    return

harvestAndSwap_else_body@3:
    bury 6
    dig 1
    b harvestAndSwap_after_if_else@4


// OrbitalVault.algo.ts::OrbitalVault.getVaultStats[routing]() -> void:
getVaultStats:
    // OrbitalVault.algo.ts:780
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // OrbitalVault.algo.ts:781
    // const cUsdcBalance = Asset(this.cUsdcAssetId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:50
    // cUsdcAssetId = GlobalState<uint64>();       // cUSDC (Orbital LST) asset ID
    bytec 4 // "cUsdcAssetId"
    // OrbitalVault.algo.ts:781
    // const cUsdcBalance = Asset(this.cUsdcAssetId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    swap
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:782
    // const asaBalance = Asset(this.projectAsaId.value).balance(appAddr);
    intc_0 // 0
    // OrbitalVault.algo.ts:51
    // projectAsaId = GlobalState<uint64>();       // Project ASA (yield paid in this)
    bytec 11 // "projectAsaId"
    // OrbitalVault.algo.ts:782
    // const asaBalance = Asset(this.projectAsaId.value).balance(appAddr);
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    asset_holding_get AssetBalance
    assert // account opted into asset
    // OrbitalVault.algo.ts:787
    // this.totalShares.value,
    intc_0 // 0
    // OrbitalVault.algo.ts:59
    // totalShares = GlobalState<uint64>();        // Total cUSDC shares held by vault
    bytec_1 // "totalShares"
    // OrbitalVault.algo.ts:787
    // this.totalShares.value,
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:788
    // this.totalPrincipal.value,
    intc_0 // 0
    // OrbitalVault.algo.ts:60
    // totalPrincipal = GlobalState<uint64>();     // Total USDC principal deposited by users
    bytec_2 // "totalPrincipal"
    // OrbitalVault.algo.ts:788
    // this.totalPrincipal.value,
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:789
    // this.lastRateSnapshot.value,
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:789
    // this.lastRateSnapshot.value,
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:786-792
    // return [
    //   this.totalShares.value,
    //   this.totalPrincipal.value,
    //   this.lastRateSnapshot.value,
    //   cUsdcBalance,
    //   asaBalance
    // ];
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // OrbitalVault.algo.ts:778
    // @arc4.abimethod({ readonly: true })
    bytec 23 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.getUserPosition[routing]() -> void:
getUserPosition:
    pushbytes ""
    dupn 3
    // OrbitalVault.algo.ts:798
    // @arc4.abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // OrbitalVault.algo.ts:800
    // const shares = this.userShares(user).value;
    intc_0 // 0
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:800
    // const shares = this.userShares(user).value;
    app_local_get_ex
    assert // check LocalState exists
    // OrbitalVault.algo.ts:801
    // const rate = this.lastRateSnapshot.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:801
    // const rate = this.lastRateSnapshot.value;
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:804-806
    // const principalValue = rate > Uint64(0)
    //   ? this.mulDivFloor(shares, rate, RATE_PRECISION)
    //   : shares;
    bz getUserPosition_ternary_false@3
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dup2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:805
    // ? this.mulDivFloor(shares, rate, RATE_PRECISION)
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    bury 6

getUserPosition_ternary_merge@4:
    // OrbitalVault.algo.ts:809
    // let unrealizedUsdc = this.userUnrealizedUsdc(user).value;
    dig 2
    intc_0 // 0
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:809
    // let unrealizedUsdc = this.userUnrealizedUsdc(user).value;
    app_local_get_ex
    swap
    bury 6
    assert // check LocalState exists
    // OrbitalVault.algo.ts:810
    // if (shares > Uint64(0)) {
    dig 1
    bz getUserPosition_after_if_else@8
    // OrbitalVault.algo.ts:811
    // const currentYPS = this.usdcYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:811
    // const currentYPS = this.usdcYieldPerShare.value;
    app_global_get_ex
    swap
    dup
    cover 2
    bury 9
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:812
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    dig 3
    intc_0 // 0
    // OrbitalVault.algo.ts:81
    // userUsdcYieldPerShare = LocalState<uint64>();   // Snapshot of usdcYieldPerShare
    bytec 13 // "userUsdcYieldPerShare"
    // OrbitalVault.algo.ts:812
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    app_local_get_ex
    swap
    dup
    cover 2
    bury 7
    assert // check LocalState exists
    // OrbitalVault.algo.ts:813
    // if (currentYPS > userYPS) {
    >
    bz getUserPosition_after_if_else@8
    // OrbitalVault.algo.ts:814
    // unrealizedUsdc = unrealizedUsdc + this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    dig 6
    dig 4
    -
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:814
    // unrealizedUsdc = unrealizedUsdc + this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:814
    // unrealizedUsdc = unrealizedUsdc + this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    dig 5
    +
    bury 5

getUserPosition_after_if_else@8:
    // OrbitalVault.algo.ts:822
    // this.earnedAsa(user).value
    dig 2
    intc_0 // 0
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:822
    // this.earnedAsa(user).value
    app_local_get_ex
    assert // check LocalState exists
    // OrbitalVault.algo.ts:818-823
    // return [
    //   shares,
    //   principalValue,
    //   unrealizedUsdc,
    //   this.earnedAsa(user).value
    // ];
    dig 2
    itob
    dig 7
    itob
    concat
    dig 6
    itob
    concat
    swap
    itob
    concat
    // OrbitalVault.algo.ts:798
    // @arc4.abimethod({ readonly: true })
    bytec 23 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getUserPosition_ternary_false@3:
    dig 1
    bury 6
    b getUserPosition_ternary_merge@4


// OrbitalVault.algo.ts::OrbitalVault.getPendingYield[routing]() -> void:
getPendingYield:
    pushbytes ""
    dup
    // OrbitalVault.algo.ts:829
    // @arc4.abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // OrbitalVault.algo.ts:831
    // const shares = this.userShares(user).value;
    dup
    intc_0 // 0
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:831
    // const shares = this.userShares(user).value;
    app_local_get_ex
    swap
    dup
    cover 3
    cover 3
    assert // check LocalState exists
    // OrbitalVault.algo.ts:834
    // let unrealizedUsdc = this.userUnrealizedUsdc(user).value;
    intc_0 // 0
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:834
    // let unrealizedUsdc = this.userUnrealizedUsdc(user).value;
    app_local_get_ex
    swap
    cover 2
    assert // check LocalState exists
    // OrbitalVault.algo.ts:835
    // if (shares > Uint64(0)) {
    bz getPendingYield_after_if_else@5
    // OrbitalVault.algo.ts:836
    // const currentYPS = this.usdcYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:836
    // const currentYPS = this.usdcYieldPerShare.value;
    app_global_get_ex
    swap
    dup
    cover 2
    bury 7
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:837
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    dig 3
    intc_0 // 0
    // OrbitalVault.algo.ts:81
    // userUsdcYieldPerShare = LocalState<uint64>();   // Snapshot of usdcYieldPerShare
    bytec 13 // "userUsdcYieldPerShare"
    // OrbitalVault.algo.ts:837
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    app_local_get_ex
    swap
    dup
    cover 2
    bury 7
    assert // check LocalState exists
    // OrbitalVault.algo.ts:838
    // if (currentYPS > userYPS) {
    >
    bz getPendingYield_after_if_else@5
    // OrbitalVault.algo.ts:839
    // unrealizedUsdc = unrealizedUsdc + this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    dig 4
    dig 4
    -
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    dig 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:839
    // unrealizedUsdc = unrealizedUsdc + this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:839
    // unrealizedUsdc = unrealizedUsdc + this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    dig 1
    +
    bury 1

getPendingYield_after_if_else@5:
    // OrbitalVault.algo.ts:843
    // return [unrealizedUsdc, this.earnedAsa(user).value];
    dig 2
    intc_0 // 0
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:843
    // return [unrealizedUsdc, this.earnedAsa(user).value];
    app_local_get_ex
    assert // check LocalState exists
    dig 1
    itob
    swap
    itob
    concat
    // OrbitalVault.algo.ts:829
    // @arc4.abimethod({ readonly: true })
    bytec 23 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.setPaused[routing]() -> void:
setPaused:
    // OrbitalVault.algo.ts:853
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // OrbitalVault.algo.ts:855
    // assert(Txn.sender === this.creator.value, 'Only creator can pause');
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:42
    // creator = GlobalState<Account>();           // Vault creator/admin
    bytec 10 // "creator"
    // OrbitalVault.algo.ts:855
    // assert(Txn.sender === this.creator.value, 'Only creator can pause');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only creator can pause
    // OrbitalVault.algo.ts:46
    // isPaused = GlobalState<boolean>();          // Emergency pause flag
    bytec 7 // "isPaused"
    // OrbitalVault.algo.ts:856
    // this.isPaused.value = paused;
    swap
    app_global_put
    // OrbitalVault.algo.ts:853
    // @arc4.abimethod()
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.updateMinHarvestThreshold[routing]() -> void:
updateMinHarvestThreshold:
    // OrbitalVault.algo.ts:862
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // OrbitalVault.algo.ts:864
    // const isCreator = Txn.sender === this.creator.value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:42
    // creator = GlobalState<Account>();           // Vault creator/admin
    bytec 10 // "creator"
    // OrbitalVault.algo.ts:864
    // const isCreator = Txn.sender === this.creator.value;
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // OrbitalVault.algo.ts:865
    // const isRarefi = Txn.sender === this.rarefiAddress.value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:43
    // rarefiAddress = GlobalState<Account>();     // RareFi platform address
    bytec 14 // "rarefiAddress"
    // OrbitalVault.algo.ts:865
    // const isRarefi = Txn.sender === this.rarefiAddress.value;
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // OrbitalVault.algo.ts:866
    // assert(isCreator || isRarefi, 'Only creator or RareFi can update');
    ||
    assert // Only creator or RareFi can update
    // OrbitalVault.algo.ts:867
    // assert(threshold >= MIN_HARVEST_THRESHOLD, 'Threshold too low');
    dup
    intc_2 // 1000000
    >=
    assert // Threshold too low
    // OrbitalVault.algo.ts:70
    // minHarvestThreshold = GlobalState<uint64>();      // Minimum USDC yield before harvest
    bytec 20 // "minHarvestThreshold"
    // OrbitalVault.algo.ts:868
    // this.minHarvestThreshold.value = threshold;
    swap
    app_global_put
    // OrbitalVault.algo.ts:862
    // @arc4.abimethod()
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.updateTinymanPool[routing]() -> void:
updateTinymanPool:
    // OrbitalVault.algo.ts:874
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // OrbitalVault.algo.ts:876
    // const isCreator = Txn.sender === this.creator.value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:42
    // creator = GlobalState<Account>();           // Vault creator/admin
    bytec 10 // "creator"
    // OrbitalVault.algo.ts:876
    // const isCreator = Txn.sender === this.creator.value;
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // OrbitalVault.algo.ts:877
    // const isRarefi = Txn.sender === this.rarefiAddress.value;
    txn Sender
    intc_0 // 0
    // OrbitalVault.algo.ts:43
    // rarefiAddress = GlobalState<Account>();     // RareFi platform address
    bytec 14 // "rarefiAddress"
    // OrbitalVault.algo.ts:877
    // const isRarefi = Txn.sender === this.rarefiAddress.value;
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // OrbitalVault.algo.ts:878
    // assert(isCreator || isRarefi, 'Only creator or RareFi can update');
    ||
    assert // Only creator or RareFi can update
    // OrbitalVault.algo.ts:879
    // assert(poolAppId !== Uint64(0), 'Invalid pool app ID');
    dig 1
    assert // Invalid pool app ID
    // OrbitalVault.algo.ts:55
    // tinymanPoolAppId = GlobalState<uint64>();   // Tinyman V2 pool app ID
    bytec 16 // "tinymanPoolAppId"
    // OrbitalVault.algo.ts:880
    // this.tinymanPoolAppId.value = poolAppId;
    uncover 2
    app_global_put
    // OrbitalVault.algo.ts:56
    // tinymanPoolAddress = GlobalState<Account>();// Tinyman pool address
    bytec 17 // "tinymanPoolAddress"
    // OrbitalVault.algo.ts:881
    // this.tinymanPoolAddress.value = poolAddress;
    swap
    app_global_put
    // OrbitalVault.algo.ts:874
    // @arc4.abimethod()
    intc_1 // 1
    return


// OrbitalVault.algo.ts::OrbitalVault.mulDivCeil(n1: uint64, n2: uint64, d: uint64) -> uint64:
mulDivCeil:
    // OrbitalVault.algo.ts:103
    // private mulDivCeil(n1: uint64, n2: uint64, d: uint64): uint64 {
    proto 3 1
    // OrbitalVault.algo.ts:104
    // const [hi, lo] = mulw(n1, n2);
    frame_dig -3
    frame_dig -2
    mulw
    // OrbitalVault.algo.ts:105
    // const [q_hi, q_lo, r_hi, r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    frame_dig -1
    divmodw
    cover 3
    cover 3
    cover 2
    // OrbitalVault.algo.ts:106
    // assert(q_hi === Uint64(0), 'Overflow in mulDivCeil');
    !
    assert // Overflow in mulDivCeil
    // OrbitalVault.algo.ts:107
    // if (r_lo > Uint64(0) || r_hi > Uint64(0)) {
    bnz mulDivCeil_if_body@2
    frame_dig 0
    bz mulDivCeil_after_if_else@3

mulDivCeil_if_body@2:
    // OrbitalVault.algo.ts:108
    // return q_lo + Uint64(1);
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 0
    retsub

mulDivCeil_after_if_else@3:
    // OrbitalVault.algo.ts:110
    // return q_lo;
    frame_dig 1
    frame_bury 0
    retsub


// OrbitalVault.algo.ts::OrbitalVault.fetchCurrentRate() -> uint64:
fetchCurrentRate:
    // OrbitalVault.algo.ts:117
    // private fetchCurrentRate(): uint64 {
    proto 0 1
    pushbytes ""
    // OrbitalVault.algo.ts:118
    // const orbitalApp = this.orbitalAppId.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:54
    // orbitalAppId = GlobalState<uint64>();       // Orbital Lending app ID
    bytec 12 // "orbitalAppId"
    // OrbitalVault.algo.ts:118
    // const orbitalApp = this.orbitalAppId.value;
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:121
    // const [totalDeposits, hasTotalDeposits] = AppGlobal.getExUint64(orbitalApp, Bytes('total_deposits'));
    dup
    pushbytes "total_deposits"
    app_global_get_ex
    uncover 2
    // OrbitalVault.algo.ts:122
    // const [circulatingLst, hasCirculatingLst] = AppGlobal.getExUint64(orbitalApp, Bytes('circulating_lst'));
    pushbytes "circulating_lst"
    app_global_get_ex
    cover 2
    swap
    // OrbitalVault.algo.ts:125
    // if (!hasTotalDeposits || !hasCirculatingLst) {
    bz fetchCurrentRate_if_body@2
    frame_dig 2
    bnz fetchCurrentRate_after_if_else@3

fetchCurrentRate_if_body@2:
    // OrbitalVault.algo.ts:126
    // return RATE_PRECISION; // Default to 1.0 rate
    intc_2 // 1000000
    frame_bury 0
    retsub

fetchCurrentRate_after_if_else@3:
    // OrbitalVault.algo.ts:129
    // if (circulatingLst === Uint64(0)) {
    frame_dig 3
    bnz fetchCurrentRate_after_if_else@5
    // OrbitalVault.algo.ts:130
    // return RATE_PRECISION; // Default to 1.0 if no LST in circulation
    intc_2 // 1000000
    frame_bury 0
    retsub

fetchCurrentRate_after_if_else@5:
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    frame_dig 1
    // OrbitalVault.algo.ts:134
    // const rate = this.mulDivFloor(totalDeposits, RATE_PRECISION, circulatingLst);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    frame_dig 3
    divmodw
    popn 2
    frame_bury 0
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:138
    // if (this.lastRateSnapshot.value > Uint64(0)) {
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:138
    // if (this.lastRateSnapshot.value > Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    bz fetchCurrentRate_after_if_else@7
    // OrbitalVault.algo.ts:140
    // const minRate = this.mulDivFloor(this.lastRateSnapshot.value, Uint64(999), Uint64(1000));
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:140
    // const minRate = this.mulDivFloor(this.lastRateSnapshot.value, Uint64(999), Uint64(1000));
    app_global_get_ex
    assert // check GlobalState exists
    pushint 999 // 999
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:140
    // const minRate = this.mulDivFloor(this.lastRateSnapshot.value, Uint64(999), Uint64(1000));
    pushint 1000 // 1000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:141
    // assert(rate >= minRate, 'Rate decreased abnormally');
    frame_dig 0
    <=
    assert // Rate decreased abnormally

fetchCurrentRate_after_if_else@7:
    // OrbitalVault.algo.ts:144
    // return rate;
    retsub


// OrbitalVault.algo.ts::OrbitalVault.updateUsdcYieldAccumulator() -> void:
updateUsdcYieldAccumulator:
    // OrbitalVault.algo.ts:151
    // private updateUsdcYieldAccumulator(): void {
    proto 0 0
    // OrbitalVault.algo.ts:152
    // const currentRate = this.fetchCurrentRate();
    callsub fetchCurrentRate
    dup
    // OrbitalVault.algo.ts:154
    // if (currentRate > this.lastRateSnapshot.value && this.lastRateSnapshot.value > Uint64(0)) {
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:154
    // if (currentRate > this.lastRateSnapshot.value && this.lastRateSnapshot.value > Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz updateUsdcYieldAccumulator_after_if_else@3
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:154
    // if (currentRate > this.lastRateSnapshot.value && this.lastRateSnapshot.value > Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    bz updateUsdcYieldAccumulator_after_if_else@3
    // OrbitalVault.algo.ts:156
    // const rateIncrease: uint64 = currentRate - this.lastRateSnapshot.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:156
    // const rateIncrease: uint64 = currentRate - this.lastRateSnapshot.value;
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 0
    swap
    -
    // OrbitalVault.algo.ts:157
    // this.usdcYieldPerShare.value = this.usdcYieldPerShare.value + rateIncrease;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:157
    // this.usdcYieldPerShare.value = this.usdcYieldPerShare.value + rateIncrease;
    app_global_get_ex
    assert // check GlobalState exists
    +
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:157
    // this.usdcYieldPerShare.value = this.usdcYieldPerShare.value + rateIncrease;
    swap
    app_global_put

updateUsdcYieldAccumulator_after_if_else@3:
    // OrbitalVault.algo.ts:65
    // lastRateSnapshot = GlobalState<uint64>();   // Exchange rate at last checkpoint
    bytec_0 // "lastRateSnapshot"
    // OrbitalVault.algo.ts:160
    // this.lastRateSnapshot.value = currentRate;
    frame_dig 0
    app_global_put
    retsub


// OrbitalVault.algo.ts::OrbitalVault.updateUserUsdcYield(user: bytes) -> void:
updateUserUsdcYield:
    // OrbitalVault.algo.ts:167
    // private updateUserUsdcYield(user: Account): void {
    proto 1 0
    pushbytes ""
    dup
    // OrbitalVault.algo.ts:168
    // const shares = this.userShares(user).value;
    frame_dig -1
    intc_0 // 0
    // OrbitalVault.algo.ts:80
    // userShares = LocalState<uint64>();              // User's cUSDC share balance
    bytec 6 // "userShares"
    // OrbitalVault.algo.ts:168
    // const shares = this.userShares(user).value;
    app_local_get_ex
    swap
    dup
    uncover 2
    assert // check LocalState exists
    // OrbitalVault.algo.ts:170
    // if (shares > Uint64(0)) {
    bz updateUserUsdcYield_after_if_else@4
    // OrbitalVault.algo.ts:171
    // const currentYPS = this.usdcYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:171
    // const currentYPS = this.usdcYieldPerShare.value;
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 0
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:172
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    frame_dig -1
    intc_0 // 0
    // OrbitalVault.algo.ts:81
    // userUsdcYieldPerShare = LocalState<uint64>();   // Snapshot of usdcYieldPerShare
    bytec 13 // "userUsdcYieldPerShare"
    // OrbitalVault.algo.ts:172
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    app_local_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check LocalState exists
    // OrbitalVault.algo.ts:174
    // if (currentYPS > userYPS) {
    >
    bz updateUserUsdcYield_after_if_else@4
    // OrbitalVault.algo.ts:177
    // const pendingUsdc = this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    frame_dig 0
    frame_dig 1
    -
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    frame_dig 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:177
    // const pendingUsdc = this.mulDivFloor(shares, currentYPS - userYPS, RATE_PRECISION);
    intc_2 // 1000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:178
    // this.userUnrealizedUsdc(user).value = this.userUnrealizedUsdc(user).value + pendingUsdc;
    frame_dig -1
    intc_0 // 0
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:178
    // this.userUnrealizedUsdc(user).value = this.userUnrealizedUsdc(user).value + pendingUsdc;
    app_local_get_ex
    assert // check LocalState exists
    +
    frame_dig -1
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:178
    // this.userUnrealizedUsdc(user).value = this.userUnrealizedUsdc(user).value + pendingUsdc;
    uncover 2
    app_local_put

updateUserUsdcYield_after_if_else@4:
    // OrbitalVault.algo.ts:183
    // this.userUsdcYieldPerShare(user).value = this.usdcYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:63
    // usdcYieldPerShare = GlobalState<uint64>();  // Stage 1: Rate-based USDC yield accumulator
    bytec 5 // "usdcYieldPerShare"
    // OrbitalVault.algo.ts:183
    // this.userUsdcYieldPerShare(user).value = this.usdcYieldPerShare.value;
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    // OrbitalVault.algo.ts:81
    // userUsdcYieldPerShare = LocalState<uint64>();   // Snapshot of usdcYieldPerShare
    bytec 13 // "userUsdcYieldPerShare"
    // OrbitalVault.algo.ts:183
    // this.userUsdcYieldPerShare(user).value = this.usdcYieldPerShare.value;
    uncover 2
    app_local_put
    retsub


// OrbitalVault.algo.ts::OrbitalVault.updateUserAsaYield(user: bytes) -> void:
updateUserAsaYield:
    // OrbitalVault.algo.ts:190
    // private updateUserAsaYield(user: Account): void {
    proto 1 0
    pushbytes ""
    // OrbitalVault.algo.ts:191
    // const unrealizedUsdc = this.userUnrealizedUsdc(user).value;
    frame_dig -1
    intc_0 // 0
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:191
    // const unrealizedUsdc = this.userUnrealizedUsdc(user).value;
    app_local_get_ex
    swap
    dup
    uncover 2
    assert // check LocalState exists
    // OrbitalVault.algo.ts:192
    // const harvestAsaPerUsdc = this.lastHarvestAsaPerUsdc.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:69
    // lastHarvestAsaPerUsdc = GlobalState<uint64>();    // Conversion rate from last harvest
    bytec 19 // "lastHarvestAsaPerUsdc"
    // OrbitalVault.algo.ts:192
    // const harvestAsaPerUsdc = this.lastHarvestAsaPerUsdc.value;
    app_global_get_ex
    swap
    cover 2
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:194
    // if (unrealizedUsdc > Uint64(0) && harvestAsaPerUsdc > Uint64(0)) {
    bz updateUserAsaYield_after_if_else@7
    frame_dig 2
    bz updateUserAsaYield_after_if_else@7
    // OrbitalVault.algo.ts:197
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    frame_dig -1
    intc_0 // 0
    // OrbitalVault.algo.ts:81
    // userUsdcYieldPerShare = LocalState<uint64>();   // Snapshot of usdcYieldPerShare
    bytec 13 // "userUsdcYieldPerShare"
    // OrbitalVault.algo.ts:197
    // const userYPS = this.userUsdcYieldPerShare(user).value;
    app_local_get_ex
    assert // check LocalState exists
    // OrbitalVault.algo.ts:198
    // const harvestYPS = this.lastHarvestYieldPerShare.value;
    intc_0 // 0
    // OrbitalVault.algo.ts:68
    // lastHarvestYieldPerShare = GlobalState<uint64>(); // usdcYieldPerShare at last harvest
    bytec 18 // "lastHarvestYieldPerShare"
    // OrbitalVault.algo.ts:198
    // const harvestYPS = this.lastHarvestYieldPerShare.value;
    app_global_get_ex
    assert // check GlobalState exists
    // OrbitalVault.algo.ts:200
    // if (userYPS <= harvestYPS) {
    <=
    bz updateUserAsaYield_after_if_else@7
    // OrbitalVault.algo.ts:94
    // const [hi, lo] = mulw(n1, n2);
    frame_dig 1
    frame_dig 2
    mulw
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // OrbitalVault.algo.ts:202
    // const asaFromUsdc = this.mulDivFloor(unrealizedUsdc, harvestAsaPerUsdc, ASA_SCALE);
    intc 5 // 1000000000000
    // OrbitalVault.algo.ts:95
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    dup
    cover 2
    frame_bury 0
    // OrbitalVault.algo.ts:96
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // OrbitalVault.algo.ts:203
    // if (asaFromUsdc > Uint64(0)) {
    bz updateUserAsaYield_after_if_else@7
    // OrbitalVault.algo.ts:204
    // this.earnedAsa(user).value = this.earnedAsa(user).value + asaFromUsdc;
    frame_dig -1
    intc_0 // 0
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:204
    // this.earnedAsa(user).value = this.earnedAsa(user).value + asaFromUsdc;
    app_local_get_ex
    assert // check LocalState exists
    frame_dig 0
    +
    frame_dig -1
    // OrbitalVault.algo.ts:84
    // earnedAsa = LocalState<uint64>();               // ASA yield ready to claim
    bytec 8 // "earnedAsa"
    // OrbitalVault.algo.ts:204
    // this.earnedAsa(user).value = this.earnedAsa(user).value + asaFromUsdc;
    uncover 2
    app_local_put
    // OrbitalVault.algo.ts:205
    // this.userUnrealizedUsdc(user).value = Uint64(0);
    frame_dig -1
    // OrbitalVault.algo.ts:83
    // userUnrealizedUsdc = LocalState<uint64>();      // USDC yield not yet harvested
    bytec 9 // "userUnrealizedUsdc"
    // OrbitalVault.algo.ts:205
    // this.userUnrealizedUsdc(user).value = Uint64(0);
    intc_0 // 0
    app_local_put

updateUserAsaYield_after_if_else@7:
    retsub
