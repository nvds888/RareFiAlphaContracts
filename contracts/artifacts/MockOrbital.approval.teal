#pragma version 11
#pragma typetrack false

// contracts/MockOrbital.algo.ts::MockOrbital.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 1000000
    bytecblock "total_deposits" "circulating_lst" "usdcAssetId" "creator" "cUsdcAssetId"
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:80
    // if (Txn.applicationId.id === Uint64(0)) {
    txn ApplicationID
    bnz main_after_if_else@2
    // contracts/MockOrbital.algo.ts:37
    // creator = GlobalState<Account>();
    bytec_3 // "creator"
    // contracts/MockOrbital.algo.ts:148
    // this.creator.value = Txn.sender;
    txn Sender
    app_global_put
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:149
    // this.total_deposits.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:150
    // this.circulating_lst.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // contracts/MockOrbital.algo.ts:153
    // if (Txn.numAppArgs >= Uint64(3)) {
    txn NumAppArgs
    pushint 3 // 3
    >=
    bz main_after_if_else@37
    // contracts/MockOrbital.algo.ts:154
    // const firstArg = Txn.applicationArgs(0);
    intc_0 // 0
    txnas ApplicationArgs
    // contracts/MockOrbital.algo.ts:156
    // if (firstArg.length === Uint64(4)) {
    len
    intc_2 // 4
    ==
    bz main_after_if_else@37
    // contracts/MockOrbital.algo.ts:157
    // const usdcId = btoi(Txn.applicationArgs(1));
    intc_1 // 1
    txnas ApplicationArgs
    btoi
    // contracts/MockOrbital.algo.ts:158
    // const cUsdcId = btoi(Txn.applicationArgs(2));
    pushint 2 // 2
    txnas ApplicationArgs
    btoi
    // contracts/MockOrbital.algo.ts:159
    // this.initialize(usdcId, cUsdcId);
    callsub initialize

main_after_if_else@37:
    // contracts/MockOrbital.algo.ts:163
    // return true;
    intc_1 // 1
    // contracts/MockOrbital.algo.ts:81
    // return this.onCreate();
    return

main_after_if_else@2:
    // contracts/MockOrbital.algo.ts:85
    // if (Txn.numAppArgs === Uint64(0)) {
    txn NumAppArgs
    bnz main_after_if_else@4
    // contracts/MockOrbital.algo.ts:86
    // return false; // No bare calls supported
    err

main_after_if_else@4:
    // contracts/MockOrbital.algo.ts:89
    // const action = Txn.applicationArgs(0);
    intc_0 // 0
    txnas ApplicationArgs
    dup
    bury 2
    // contracts/MockOrbital.algo.ts:91
    // if (action === Bytes('initialize')) {
    pushbytes "initialize"
    ==
    bz main_after_if_else@6
    // contracts/MockOrbital.algo.ts:92
    // const usdcId = btoi(Txn.applicationArgs(1));
    intc_1 // 1
    txnas ApplicationArgs
    btoi
    // contracts/MockOrbital.algo.ts:93
    // const cUsdcId = btoi(Txn.applicationArgs(2));
    pushint 2 // 2
    txnas ApplicationArgs
    btoi
    // contracts/MockOrbital.algo.ts:94
    // this.initialize(usdcId, cUsdcId);
    callsub initialize
    // contracts/MockOrbital.algo.ts:95
    // return true;
    intc_1 // 1
    return

main_after_if_else@6:
    // contracts/MockOrbital.algo.ts:98
    // if (action === Bytes('optInAssets')) {
    dup
    pushbytes "optInAssets"
    ==
    bz main_after_if_else@8
    // contracts/MockOrbital.algo.ts:182
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // contracts/MockOrbital.algo.ts:185-190
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // contracts/MockOrbital.algo.ts:187
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:28
    // usdcAssetId = GlobalState<uint64>();    // USDC asset ID
    bytec_2 // "usdcAssetId"
    // contracts/MockOrbital.algo.ts:187
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/MockOrbital.algo.ts:188
    // assetAmount: Uint64(0),
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    dup
    itxn_field AssetReceiver
    // contracts/MockOrbital.algo.ts:185-190
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // contracts/MockOrbital.algo.ts:189
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // contracts/MockOrbital.algo.ts:185-190
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // contracts/MockOrbital.algo.ts:193-198
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // contracts/MockOrbital.algo.ts:195
    // xferAsset: Asset(this.cUsdcAssetId.value),
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:29
    // cUsdcAssetId = GlobalState<uint64>();   // cUSDC (LST receipt token) asset ID
    bytec 4 // "cUsdcAssetId"
    // contracts/MockOrbital.algo.ts:195
    // xferAsset: Asset(this.cUsdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/MockOrbital.algo.ts:196
    // assetAmount: Uint64(0),
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // contracts/MockOrbital.algo.ts:193-198
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // contracts/MockOrbital.algo.ts:197
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // contracts/MockOrbital.algo.ts:193-198
    // itxn.assetTransfer({
    //   assetReceiver: appAddr,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: Uint64(0),
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // contracts/MockOrbital.algo.ts:100
    // return true;
    intc_1 // 1
    return

main_after_if_else@8:
    // contracts/MockOrbital.algo.ts:103
    // if (action === Bytes('deposit')) {
    dup
    pushbytes "deposit"
    ==
    bz main_after_if_else@10
    // contracts/MockOrbital.algo.ts:208
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // contracts/MockOrbital.algo.ts:209
    // const currentIndex = Txn.groupIndex;
    txn GroupIndex
    // contracts/MockOrbital.algo.ts:210
    // assert(currentIndex >= Uint64(1), 'Must follow asset transfer');
    dup
    assert // Must follow asset transfer
    // contracts/MockOrbital.algo.ts:213
    // const incomingTransfer = gtxn.AssetTransferTxn(currentIndex - Uint64(1));
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/MockOrbital.algo.ts:214
    // assert(incomingTransfer.xferAsset === Asset(this.usdcAssetId.value), 'Must transfer USDC');
    dup
    gtxns XferAsset
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:28
    // usdcAssetId = GlobalState<uint64>();    // USDC asset ID
    bytec_2 // "usdcAssetId"
    // contracts/MockOrbital.algo.ts:214
    // assert(incomingTransfer.xferAsset === Asset(this.usdcAssetId.value), 'Must transfer USDC');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Must transfer USDC
    // contracts/MockOrbital.algo.ts:215
    // assert(incomingTransfer.assetReceiver === appAddr, 'Must send to contract');
    dup
    gtxns AssetReceiver
    uncover 2
    ==
    assert // Must send to contract
    // contracts/MockOrbital.algo.ts:217
    // const usdcAmount = incomingTransfer.assetAmount;
    gtxns AssetAmount
    // contracts/MockOrbital.algo.ts:218
    // assert(usdcAmount > Uint64(0), 'Deposit amount must be positive');
    dup
    assert // Deposit amount must be positive
    // contracts/MockOrbital.algo.ts:222
    // const currentRate = this.getCurrentRate();
    callsub getCurrentRate
    // contracts/MockOrbital.algo.ts:43
    // const [hi, lo] = mulw(n1, n2);
    dig 1
    // contracts/MockOrbital.algo.ts:223
    // const cUsdcToMint = this.mulDivFloor(usdcAmount, RATE_PRECISION, currentRate);
    intc_3 // 1000000
    // contracts/MockOrbital.algo.ts:43
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // contracts/MockOrbital.algo.ts:44
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    uncover 3
    divmodw
    popn 2
    swap
    // contracts/MockOrbital.algo.ts:45
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // contracts/MockOrbital.algo.ts:225
    // assert(cUsdcToMint > Uint64(0), 'cUSDC mint amount is zero');
    dup
    assert // cUSDC mint amount is zero
    // contracts/MockOrbital.algo.ts:228
    // this.total_deposits.value = this.total_deposits.value + usdcAmount;
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:228
    // this.total_deposits.value = this.total_deposits.value + usdcAmount;
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:228
    // this.total_deposits.value = this.total_deposits.value + usdcAmount;
    swap
    app_global_put
    // contracts/MockOrbital.algo.ts:229
    // this.circulating_lst.value = this.circulating_lst.value + cUsdcToMint;
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:229
    // this.circulating_lst.value = this.circulating_lst.value + cUsdcToMint;
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    +
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:229
    // this.circulating_lst.value = this.circulating_lst.value + cUsdcToMint;
    swap
    app_global_put
    // contracts/MockOrbital.algo.ts:232-237
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: cUsdcToMint,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // contracts/MockOrbital.algo.ts:233
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/MockOrbital.algo.ts:234
    // xferAsset: Asset(this.cUsdcAssetId.value),
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:29
    // cUsdcAssetId = GlobalState<uint64>();   // cUSDC (LST receipt token) asset ID
    bytec 4 // "cUsdcAssetId"
    // contracts/MockOrbital.algo.ts:234
    // xferAsset: Asset(this.cUsdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // contracts/MockOrbital.algo.ts:232-237
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: cUsdcToMint,
    //   fee: Uint64(0),
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // contracts/MockOrbital.algo.ts:236
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // contracts/MockOrbital.algo.ts:232-237
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.cUsdcAssetId.value),
    //   assetAmount: cUsdcToMint,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // contracts/MockOrbital.algo.ts:106
    // return true;
    intc_1 // 1
    return

main_after_if_else@10:
    // contracts/MockOrbital.algo.ts:109
    // if (action === Bytes('redeem')) {
    dup
    pushbytes "redeem"
    ==
    bz main_after_if_else@12
    // contracts/MockOrbital.algo.ts:111
    // const amount = btoi(Txn.applicationArgs(1));
    intc_1 // 1
    txnas ApplicationArgs
    btoi
    // contracts/MockOrbital.algo.ts:247
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // contracts/MockOrbital.algo.ts:248
    // const currentIndex = Txn.groupIndex;
    txn GroupIndex
    // contracts/MockOrbital.algo.ts:249
    // assert(currentIndex >= Uint64(1), 'Must follow asset transfer');
    dup
    assert // Must follow asset transfer
    // contracts/MockOrbital.algo.ts:252
    // const incomingTransfer = gtxn.AssetTransferTxn(currentIndex - Uint64(1));
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/MockOrbital.algo.ts:253
    // assert(incomingTransfer.xferAsset === Asset(this.cUsdcAssetId.value), 'Must transfer cUSDC');
    dup
    gtxns XferAsset
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:29
    // cUsdcAssetId = GlobalState<uint64>();   // cUSDC (LST receipt token) asset ID
    bytec 4 // "cUsdcAssetId"
    // contracts/MockOrbital.algo.ts:253
    // assert(incomingTransfer.xferAsset === Asset(this.cUsdcAssetId.value), 'Must transfer cUSDC');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Must transfer cUSDC
    // contracts/MockOrbital.algo.ts:254
    // assert(incomingTransfer.assetReceiver === appAddr, 'Must send to contract');
    dup
    gtxns AssetReceiver
    uncover 2
    ==
    assert // Must send to contract
    // contracts/MockOrbital.algo.ts:255
    // assert(incomingTransfer.assetAmount === cUsdcAmount, 'Amount mismatch');
    gtxns AssetAmount
    dig 1
    ==
    assert // Amount mismatch
    // contracts/MockOrbital.algo.ts:257
    // assert(cUsdcAmount > Uint64(0), 'Redeem amount must be positive');
    dup
    assert // Redeem amount must be positive
    // contracts/MockOrbital.algo.ts:258
    // assert(cUsdcAmount <= this.circulating_lst.value, 'Exceeds circulating supply');
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:258
    // assert(cUsdcAmount <= this.circulating_lst.value, 'Exceeds circulating supply');
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    >=
    assert // Exceeds circulating supply
    // contracts/MockOrbital.algo.ts:262
    // const currentRate = this.getCurrentRate();
    callsub getCurrentRate
    // contracts/MockOrbital.algo.ts:43
    // const [hi, lo] = mulw(n1, n2);
    dig 1
    mulw
    // contracts/MockOrbital.algo.ts:44
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:263
    // const usdcToReturn = this.mulDivFloor(cUsdcAmount, currentRate, RATE_PRECISION);
    intc_3 // 1000000
    // contracts/MockOrbital.algo.ts:44
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    divmodw
    popn 2
    swap
    // contracts/MockOrbital.algo.ts:45
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // contracts/MockOrbital.algo.ts:265
    // assert(usdcToReturn > Uint64(0), 'USDC return amount is zero');
    dup
    assert // USDC return amount is zero
    // contracts/MockOrbital.algo.ts:266
    // assert(usdcToReturn <= this.total_deposits.value, 'Insufficient protocol reserves');
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:266
    // assert(usdcToReturn <= this.total_deposits.value, 'Insufficient protocol reserves');
    app_global_get_ex
    assert // check GlobalState exists
    dup2
    <=
    assert // Insufficient protocol reserves
    // contracts/MockOrbital.algo.ts:269
    // this.total_deposits.value = this.total_deposits.value - usdcToReturn;
    dig 1
    -
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:269
    // this.total_deposits.value = this.total_deposits.value - usdcToReturn;
    swap
    app_global_put
    // contracts/MockOrbital.algo.ts:270
    // this.circulating_lst.value = this.circulating_lst.value - cUsdcAmount;
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:270
    // this.circulating_lst.value = this.circulating_lst.value - cUsdcAmount;
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    -
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:270
    // this.circulating_lst.value = this.circulating_lst.value - cUsdcAmount;
    swap
    app_global_put
    // contracts/MockOrbital.algo.ts:273-278
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcToReturn,
    //   fee: Uint64(0),
    // }).submit();
    itxn_begin
    // contracts/MockOrbital.algo.ts:274
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/MockOrbital.algo.ts:275
    // xferAsset: Asset(this.usdcAssetId.value),
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:28
    // usdcAssetId = GlobalState<uint64>();    // USDC asset ID
    bytec_2 // "usdcAssetId"
    // contracts/MockOrbital.algo.ts:275
    // xferAsset: Asset(this.usdcAssetId.value),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // contracts/MockOrbital.algo.ts:273-278
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcToReturn,
    //   fee: Uint64(0),
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // contracts/MockOrbital.algo.ts:277
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // contracts/MockOrbital.algo.ts:273-278
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   xferAsset: Asset(this.usdcAssetId.value),
    //   assetAmount: usdcToReturn,
    //   fee: Uint64(0),
    // }).submit();
    itxn_submit
    // contracts/MockOrbital.algo.ts:113
    // return true;
    intc_1 // 1
    return

main_after_if_else@12:
    // contracts/MockOrbital.algo.ts:116
    // if (action === Bytes('accrueInterest')) {
    dup
    pushbytes "accrueInterest"
    ==
    bz main_after_if_else@14
    // contracts/MockOrbital.algo.ts:118
    // const additionalYield = btoi(Txn.applicationArgs(1));
    intc_1 // 1
    txnas ApplicationArgs
    btoi
    // contracts/MockOrbital.algo.ts:287
    // assert(Txn.sender === this.creator.value, 'Only creator can accrue interest');
    txn Sender
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:37
    // creator = GlobalState<Account>();
    bytec_3 // "creator"
    // contracts/MockOrbital.algo.ts:287
    // assert(Txn.sender === this.creator.value, 'Only creator can accrue interest');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only creator can accrue interest
    // contracts/MockOrbital.algo.ts:290
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // contracts/MockOrbital.algo.ts:291
    // const currentIndex = Txn.groupIndex;
    txn GroupIndex
    // contracts/MockOrbital.algo.ts:292
    // assert(currentIndex >= Uint64(1), 'Must follow asset transfer');
    dup
    assert // Must follow asset transfer
    // contracts/MockOrbital.algo.ts:294
    // const incomingTransfer = gtxn.AssetTransferTxn(currentIndex - Uint64(1));
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/MockOrbital.algo.ts:295
    // assert(incomingTransfer.xferAsset === Asset(this.usdcAssetId.value), 'Must transfer USDC');
    dup
    gtxns XferAsset
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:28
    // usdcAssetId = GlobalState<uint64>();    // USDC asset ID
    bytec_2 // "usdcAssetId"
    // contracts/MockOrbital.algo.ts:295
    // assert(incomingTransfer.xferAsset === Asset(this.usdcAssetId.value), 'Must transfer USDC');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Must transfer USDC
    // contracts/MockOrbital.algo.ts:296
    // assert(incomingTransfer.assetReceiver === appAddr, 'Must send to contract');
    dup
    gtxns AssetReceiver
    uncover 2
    ==
    assert // Must send to contract
    // contracts/MockOrbital.algo.ts:297
    // assert(incomingTransfer.assetAmount >= additionalYield, 'Insufficient USDC sent');
    gtxns AssetAmount
    dig 1
    >=
    assert // Insufficient USDC sent
    // contracts/MockOrbital.algo.ts:301
    // this.total_deposits.value = this.total_deposits.value + additionalYield;
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:301
    // this.total_deposits.value = this.total_deposits.value + additionalYield;
    app_global_get_ex
    assert // check GlobalState exists
    +
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:301
    // this.total_deposits.value = this.total_deposits.value + additionalYield;
    swap
    app_global_put
    // contracts/MockOrbital.algo.ts:120
    // return true;
    intc_1 // 1
    return

main_after_if_else@14:
    // contracts/MockOrbital.algo.ts:123
    // if (action === Bytes('getRate')) {
    dup
    pushbytes "getRate"
    ==
    bz main_after_if_else@16
    // contracts/MockOrbital.algo.ts:125
    // return true;
    intc_1 // 1
    return

main_after_if_else@16:
    // contracts/MockOrbital.algo.ts:128
    // if (action === Bytes('fundProtocol')) {
    dup
    pushbytes "fundProtocol"
    ==
    bz main_after_if_else@18
    // contracts/MockOrbital.algo.ts:309
    // assert(Txn.sender === this.creator.value, 'Only creator can fund protocol');
    txn Sender
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:37
    // creator = GlobalState<Account>();
    bytec_3 // "creator"
    // contracts/MockOrbital.algo.ts:309
    // assert(Txn.sender === this.creator.value, 'Only creator can fund protocol');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only creator can fund protocol
    // contracts/MockOrbital.algo.ts:311
    // const appAddr: Account = Global.currentApplicationAddress;
    global CurrentApplicationAddress
    // contracts/MockOrbital.algo.ts:312
    // const currentIndex = Txn.groupIndex;
    txn GroupIndex
    // contracts/MockOrbital.algo.ts:313
    // assert(currentIndex >= Uint64(1), 'Must follow asset transfer');
    dup
    assert // Must follow asset transfer
    // contracts/MockOrbital.algo.ts:317
    // const incomingTransfer = gtxn.AssetTransferTxn(currentIndex - Uint64(1));
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/MockOrbital.algo.ts:318
    // assert(incomingTransfer.assetReceiver === appAddr, 'Must send to contract');
    gtxns AssetReceiver
    ==
    assert // Must send to contract
    // contracts/MockOrbital.algo.ts:131
    // return true;
    intc_1 // 1
    return

main_after_if_else@18:
    // contracts/MockOrbital.algo.ts:134
    // return false; // Unknown action
    err


// contracts/MockOrbital.algo.ts::MockOrbital.getCurrentRate() -> uint64:
getCurrentRate:
    // contracts/MockOrbital.algo.ts:67
    // private getCurrentRate(): uint64 {
    proto 0 1
    // contracts/MockOrbital.algo.ts:68
    // const circulatingLst = this.circulating_lst.value;
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:34
    // circulating_lst = GlobalState<uint64>();  // Total cUSDC minted (in circulation)
    bytec_1 // "circulating_lst"
    // contracts/MockOrbital.algo.ts:68
    // const circulatingLst = this.circulating_lst.value;
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // contracts/MockOrbital.algo.ts:69
    // if (circulatingLst === Uint64(0)) {
    bnz getCurrentRate_after_if_else@2
    // contracts/MockOrbital.algo.ts:70
    // return INITIAL_RATE;
    intc_3 // 1000000
    swap
    retsub

getCurrentRate_after_if_else@2:
    // contracts/MockOrbital.algo.ts:72
    // return this.mulDivFloor(this.total_deposits.value, RATE_PRECISION, circulatingLst);
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:33
    // total_deposits = GlobalState<uint64>();   // Total USDC deposited in protocol
    bytec_0 // "total_deposits"
    // contracts/MockOrbital.algo.ts:72
    // return this.mulDivFloor(this.total_deposits.value, RATE_PRECISION, circulatingLst);
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 1000000
    // contracts/MockOrbital.algo.ts:43
    // const [hi, lo] = mulw(n1, n2);
    mulw
    // contracts/MockOrbital.algo.ts:44
    // const [q_hi, q_lo, _r_hi, _r_lo] = divmodw(hi, lo, Uint64(0), d);
    intc_0 // 0
    frame_dig 0
    divmodw
    popn 2
    swap
    // contracts/MockOrbital.algo.ts:45
    // assert(q_hi === Uint64(0), 'Overflow in mulDivFloor');
    !
    assert // Overflow in mulDivFloor
    // contracts/MockOrbital.algo.ts:72
    // return this.mulDivFloor(this.total_deposits.value, RATE_PRECISION, circulatingLst);
    swap
    retsub


// contracts/MockOrbital.algo.ts::MockOrbital.initialize(usdcId: uint64, cUsdcId: uint64) -> void:
initialize:
    // contracts/MockOrbital.algo.ts:169
    // private initialize(usdcId: uint64, cUsdcId: uint64): void {
    proto 2 0
    // contracts/MockOrbital.algo.ts:170
    // assert(Txn.sender === this.creator.value, 'Only creator can initialize');
    txn Sender
    intc_0 // 0
    // contracts/MockOrbital.algo.ts:37
    // creator = GlobalState<Account>();
    bytec_3 // "creator"
    // contracts/MockOrbital.algo.ts:170
    // assert(Txn.sender === this.creator.value, 'Only creator can initialize');
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only creator can initialize
    // contracts/MockOrbital.algo.ts:171
    // assert(usdcId !== Uint64(0), 'Invalid USDC asset ID');
    frame_dig -2
    assert // Invalid USDC asset ID
    // contracts/MockOrbital.algo.ts:172
    // assert(cUsdcId !== Uint64(0), 'Invalid cUSDC asset ID');
    frame_dig -1
    assert // Invalid cUSDC asset ID
    // contracts/MockOrbital.algo.ts:28
    // usdcAssetId = GlobalState<uint64>();    // USDC asset ID
    bytec_2 // "usdcAssetId"
    // contracts/MockOrbital.algo.ts:174
    // this.usdcAssetId.value = usdcId;
    frame_dig -2
    app_global_put
    // contracts/MockOrbital.algo.ts:29
    // cUsdcAssetId = GlobalState<uint64>();   // cUSDC (LST receipt token) asset ID
    bytec 4 // "cUsdcAssetId"
    // contracts/MockOrbital.algo.ts:175
    // this.cUsdcAssetId.value = cUsdcId;
    frame_dig -1
    app_global_put
    retsub
